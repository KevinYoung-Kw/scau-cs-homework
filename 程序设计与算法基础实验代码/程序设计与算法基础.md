# 程序设计与算法基础

[toc]

------



## 1. 四个常见问题

### 18104 练习使用多case解题

时间限制:1000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC

**Description**

```
多CASE的问题在般有3种情形：（1）有一个数字开始表明CASE数目；（2）以特殊标志表示结束；（3）要求处理到最后一行。
现要求你在程序一次运行中，依次处理上述3种情况。

有三批测试数据，第1批测试数据，开头会以一个数字告之该批CASE数量，每一个CASE是两个正整数；
第1批测试数据结束后，紧接着是第2批数据，每一个CASE同样是两个正整数，第2批测试数据以两个0结束；
第2批测试数据结束后，紧接着是第3批数据，每一个CASE也是两个正整数，第3批测试数据一直到数据输入结束；

要求，每一个CASE，输出两数的最小公倍数
第1批测试数据处理完毕时，输出“group 1 done”
第2批测试数据处理完毕时，输出“group 2 done”
第3批测试数据处理完毕时，输出“group 3 done”
```



**输入格式**

```
有三批测试数据，第1批测试数据，开头会以一个数字告之该批CASE数量，每一个CASE是两个正整数(最大2的31次方)；
第1批测试数据结束后，紧接着是第2批数据，每一个CASE同样是两个正整数，第2批测试数据以两个0结束；
第2批测试数据结束后，紧接着是第3批数据，每一个CASE也是两个正整数，第3批测试数据一直到数据输入结束；
```



**输出格式**

```
要求，每一个CASE，输出两数的最小公倍数
第1批测试数据处理完毕时，输出“group 1 done”
第2批测试数据处理完毕时，输出“group 2 done”
第3批测试数据处理完毕时，输出“group 3 done”
```



**输入样例**

```
2
6 10
5 12
8 16
12 18
8 4
0 0
4 5
4 6
```



**输出样例**

```
30
60
group 1 done
16
36
8
group 2 done
20
12
group 3 done
```



**参考代码**

 ```cpp
 #include<iostream>
 #include<algorithm>
 // algorithm下有__gcd函数
 // 谨防万一还是补充一下gcd函数好了
 
 long long abs(long long a) {
     return (a > 0) ? a : -a;
 }
 
 long long gcd(long long a, long long b) {
     a = abs(a);
     b = abs(b);
     long long c = a % b;
     while (c) {
         a = b;
         b = c;
         c = a % b;
     }
     return b;
 }
 
 long long lcm(long long a, long long b) {
     return (a * b) / gcd(a, b);
 }
     
 
 using namespace std;
 int main(){
 	long long a,b,n;
 	cin>>n;
 	while(n--){
 		cin>>a>>b;
 		cout<<a*b/__gcd(a,b)<<endl;
 	}
 	cout<<"group 1 done"<<endl;
 	a=1;
 	while(a!=0||b!=0){
 		cin>>a>>b;
 		if(a==0&&b==0) break;
 		cout<<a*b/__gcd(a,b)<<endl;
 	}
 	cout<<"group 2 done"<<endl;
 	while(scanf("%lld %lld",&a,&b)!=EOF){
 		cout<<a*b/__gcd(a,b)<<endl;
 	}
 	cout<<"group 3 done"<<endl;
 	return 0;
 }
 ```



## 2. C++ STL的应用

### 9116 丑数

时间限制:1000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC

**Description**

```
“丑数”是指除了质因子2,3，5，不含其它质因子的正整数，例如由小到大前10个“丑数”为
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, ...
现要求编写一个程序，输出指定第几位的“丑数”。
```



**输入格式**

```
第一行为正整数T（T<=10000）, 表示case的数目。
此后T行，每行一个正整数 n (n <= 100000000).
```



**输出格式**

```
每一个n，输出第n个“丑数”
```



**输入样例**

```
3
1
2
9
```



**输出样例**

```
1
2
10
```



**参考代码**

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <set>

using namespace std;
typedef long long LL;

const int coeff[3] = {2, 3, 5};

int main() {
    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int nn;
        cin >> nn;

        priority_queue<LL, vector<LL>, greater<LL>> productor;
        set<LL> s;

        productor.push(1);
        s.insert(1);

        for (int i = 1; ; i++) {
            LL x = productor.top();
            productor.pop();

            if (i == nn) {
                cout << x << endl;
                break;
            }

            for (int j = 0; j < 3; j++) {
                LL x2 = x * coeff[j];
                if (!s.count(x2)) {
                    s.insert(x2);
                    productor.push(x2);
                }
            }
        }
    }
    return 0;
}

```



### 18440 走迷宫

时间限制:1000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题 语言: G++;GCC;VC

**Description**

有一个N*M(N,M<=10)的格子迷宫，1代表该格子为墙，不能通过，0代表可以通过，人在迷宫中可以尝试上下左右四个方向移动。
另外，在迷宫中如果从左边走出迷宫会回到迷宫最右边一格（只要该格不是墙），行不变，同样，从右边走出迷宫会
回到迷宫最左边一格，向上走出迷宫会回到迷宫最下边一格，向下走出迷宫会回到迷宫最上边一格。
现在给定一个迷宫，以及起点和终点，问最少多少步可以走出迷宫。如果不能走出迷宫输出“die”



**输入格式**

该程序为多CASE，第1行为CASE的数量
每一个CASE，第1行为两个数N（行）和M（列）
然后N行每行M个数，之后是起点坐标和终点坐标 sc(行) sr(列) ec(行) er(列)



**输出格式**

如题



**输入样例**

```
2
4 3
011
010
110
110
0 0 3 2
2 2
01
10
0 0 1 1
```



**输出样例**

```
4
die
```

**提示**

第一个case，可以从（1，0）走到（1，2）

```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <string>
using namespace std;

const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};

string bfs(vector<vector<int>>& maze, pair<int, int> start, pair<int, int> end) {
    int n = maze.size(), m = maze[0].size();
    queue<pair<int, int>> q;
    vector<vector<int>> visited(n, vector<int>(m, 0));
    q.push(start);
    visited[start.first][start.second] = 1;

    while (!q.empty()) {
        pair<int, int> cur = q.front();
        int x = cur.first, y = cur.second;
        q.pop();

        if (x == end.first && y == end.second) {
            return to_string(visited[x][y] - 1);
        }

        for (int i = 0; i < 4; i++) {
            int nx = (x + dx[i] + n) % n;
            int ny = (y + dy[i] + m) % m;
            if (maze[nx][ny] == 0 && !visited[nx][ny]) {
                visited[nx][ny] = visited[x][y] + 1;
                q.push({nx, ny});
            }
        }
    }

    return "die";
}

int main() {
    int cases;
    cin >> cases;

    while (cases--) {
        int n, m;
        cin >> n >> m;
        vector<vector<int>> maze(n, vector<int>(m));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                scanf("%1d", &maze[i][j]);
            }
        }

        int sr, sc, er, ec;
        cin >> sr >> sc >> er >> ec;
        pair<int, int> start = {sr, sc};
        pair<int, int> end = {er, ec};

        cout << bfs(maze, start, end) << endl;
    }

    return 0;
}
```



### 18276 走迷宫2

**Description**

```
有一个N*M的格子迷宫，1代表该格子为墙，不能通过，0代表可以通过，另外，在迷宫中
有一些传送门，走到传送门的入口即会自动被传送到传送门的出口（一次传送算1步）。人在迷宫中可以尝试
上下左右四个方向移动。现在给定一个迷宫和所有传送门的出入口，以及起点和终点，
问最少多少步可以走出迷宫。如果不能走出迷宫输出“die”。
```



**输入格式**

```
该程序为多CASE，第1行为CASE的数量
每一个CASE，第1行为两个数N（行）和M（列）
然后N行每行M个数
之后是一个数W，为传送门的数量
之后每行一个传送门的入口坐标c1(行),r1(列)和出口坐标c2,r2
之后是起点坐标和终点坐标sc(行) sr(列) ec(行) er(列)

注：传送门出入口和起点坐标和终点坐标不会出现在墙的位置
所有数字不超过100
```



**输出格式**

```
如题
```



**输入样例**

```
2
4 3
011
011
110
110
1
1 0 2 2
0 0 3 2
2 2
01
10
0
0 0 1 1
```



**输出样例**

```
3
die
```



**参考代码**

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <queue>

using namespace std;

// 定义方向数组，用于移动
const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

// 判断是否为有效坐标
bool isValid(int x, int y, int N, int M, const vector<vector<int>>& maze) {
    return x >= 0 && x < N && y >= 0 && y < M && maze[x][y] == 0;
}

// 广度优先搜索
int bfs(int sc, int sr, int ec, int er, const vector<vector<int>>& maze, map<pair<int, int>, pair<int, int>>& portals) {
    int N = maze.size();
    int M = maze[0].size();
    vector<vector<bool>> visited(N, vector<bool>(M, false));
    queue<pair<int, int>> q;

    visited[sc][sr] = true;
    q.push({sc, sr});
    int steps = 0;

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            auto [x, y] = q.front();
            q.pop();

            // 检查是否到达终点
            if (x == ec && y == er) {
                return steps;
            }

            // 检查当前节点是否为传送门入口
            pair<int, int> current = {x, y};
            if (portals.find(current) != portals.end()) {
                pair<int, int> destination = portals[current];
                if (!visited[destination.first][destination.second]) {
                    visited[destination.first][destination.second] = true;
                    q.push(destination);
                }
            }

            // 尝试四个方向移动
            for (int j = 0; j < 4; j++) {
                int newX = x + dx[j];
                int newY = y + dy[j];
                if (isValid(newX, newY, N, M, maze) && !visited[newX][newY]) {
                    visited[newX][newY] = true;
                    q.push({newX, newY});
                }
            }
        }
        steps++;
    }

    return -1;
}

int main() {
    int caseCount;
    cin >> caseCount;

    while (caseCount--) {
        int N, M;
        cin >> N >> M;

        vector<vector<int>> maze(N, vector<int>(M));
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                scanf("%1d", &maze[i][j]);
            }
        }

        int W;
        cin >> W;

        map<pair<int, int>, pair<int, int>> portals;
        for (int i = 0; i < W; i++) {
            int c1, r1, c2, r2;
            cin >> c1 >> r1 >> c2 >> r2;
            portals[{c1, r1}] = {c2, r2};
        }

        int sc, sr, ec, er;
        cin >> sc >> sr >> ec >> er;

        int result = bfs(sc, sr, ec, er, maze, portals);

        if (result == -1) {
            cout << "die" << endl;
        } else {
            cout << result << endl;
        }
    }

    return 0;
}
```



### 18105 银行的叫号顺序

**Description**

```
银行的叫号过程是一个优先队列的典型应用，假设，银行有4类客户，分别用优先级1，2，3，4表示，级别越高
则更优先得到服务，例如，当前有三个人排队，两个1级客户，一个3级客户，则银行叫号时，3级客户将先得到服务
，即使另两个1级有客户比他先到。当多个同级的客户将获得服务时，由先到的客户先得到服务。

假设，银行只有一个服务窗口，一次只能服务一个客户，假设该窗口每5分钟服务一个客户，即叫号的时刻分别
为0分钟、5分钟、10分钟、.....如果在叫号的时侯，没有客户，银行职员会去喝杯咖啡或上个洗手间，5分钟后
再继续叫号。

银行给出一系列客户到来的记录，每条记录包括“客户到来的时”，“客户等级”，“客户姓名”（由一个单词构成），请输
出银行服务的客户的顺序。
```



**输入格式**

```
第一数字是客户的数量n（n<=100000）
此后，每一行是一个客户来访信息，包括3个数字，到来的时刻（分钟整点,最大10的8次方）、等级、姓名（最多20个字母）
（已经按到来时刻排序）
```



**输出格式**

```
按服务的先后顺序输出客户的姓名
```



**输入样例**

```
4
0 1 John
3 1 Smith
3 1 Tom
4 2 Flod
```



**输出样例**

```
John
Flod
Smith
Tom
```



**参考代码**

```cpp
#include<iostream>
#include<queue>
#include<string>
#include<algorithm>

using namespace std;
typedef pair<int,string> person; // 定义一个类型 person，它是一个包含整数和字符串的对
priority_queue <person> q; // 定义一个优先队列，存储 person 类型的数据

int main() {
    int time, sumtime = 0, pos = 99999, n, imp; // 初始化变量
    string name;
    cin >> n; // 读取客户数量

    while(n--) { // 循环读取每个客户的信息
        cin >> time >> imp >> name; // 读取客户到达时间、优先级和姓名
        while(1) {
            if(time <= sumtime) { // 如果客户到达时间小于等于当前时间
                q.push(make_pair(imp * 100000 + pos, name)); // 将客户加入优先队列
                pos--; // 递减 pos 确保同优先级的客户按到达顺序处理
                break;
            }
            else if(!q.empty()) { // 如果当前时间没有客户到达且队列不为空
                cout << q.top().second << endl; // 输出队列中优先级最高的客户
                q.pop(); // 从队列中移除该客户
            }
            sumtime += 5; // 每次处理完一个客户，时间增加 5 分钟
        }
    }

    // 处理剩余的客户
    while(!q.empty()) {
        cout << q.top().second << endl;
        q.pop();
    }

    return 0;
}

```



### 18216 银行服务

**Description**

```
银行通过叫号来决定服务用户的顺序，假设，银行有4类客户，分别用优先级1，2，3，4表示，级别越高
则更优先得到服务，例如，当前有三个人排队，两个1级客户，一个3级客户，则银行叫号时，3级客户将先得到服务
，即使另两个1级的客户比他先到。当多个同级的客户将获得服务时，由先到的客户先得到服务。

假设，银行只有一个服务窗口，一次只能服务一个客户，假设该窗口每5分钟服务一个客户，即叫号的时刻分别
为0分钟、5分钟、10分钟、.....如果在叫号的时侯，没有客户，银行职员会去喝杯咖啡或上个洗手间，5分钟后
再继续叫号。

有一种情况，银行工作到一定时间是要下班的，所以到一定时间，如果后面还有客户，将不再提供服务。

银行给出一系列客户到来的记录，每条记录包括“客户到来的时间”，“客户等级”，“客户姓名”（由一个单词构成），请输
出该银行这一轮服务的客户的顺序。
```



**输入格式**

```
第一行两个数字，第一数字是客户的数量n（n<=100000），第二个数字是银行关门的时间，到这个时间，即关门，该点及之后，
不再叫号，但之前已经叫号的客户会继续服务到完结。
此后，每一行是一个客户来访信息，包括3个数字，到来的时刻（分钟整点,最大10的8次方）、等级、姓名（最多20个字母）
（已经按到来时刻排序，注意：同一时刻可能会同时到来多个客户，这时若为同等级的，数据出现得早的稍早得到服务）
```



**输出格式**

```
按服务的先后顺序输出客户的姓名
```



**输入样例**

```
4 12
0 1 John
3 1 Smith
3 1 Tom
4 2 Flod
```



**输出样例**

```
John
Flod
Smith
```



> 两个题目在逻辑和处理上有些相似，但有一些关键的不同点：
>
> 1. **关门时间**：第二个题目引入了一个关门时间的概念，即在关门时间后，不再接收新的客户。但是，关门时间之前已经在队列中的客户会继续服务直到队列为空。
> 2. **输入格式**：第二个题目除了客户数量，还需要输入银行的关门时间。
>
> 基于这些不同点，下面是第二个题目的解决方案，改进后的代码将处理关门时间以及之前的逻辑。



**参考代码**

```cpp
#include <queue>
#include <iostream>
#include <cstring>

using namespace std;

priority_queue<pair<int, string>> q;

int main() {
    int n, t0;
    cin >> n >> t0;
    int grade, time, realtime = 0, ret = 99999;
    char name[22];

    while (n--) {
            cin >> time >> grade >> name;
            here:
                if (time <= realtime) {
                    q.push(make_pair(ret + 100000*grade, name));
                    ret--;
                    continue;
                }
                if (!q.empty()) {
                    cout << q.top().second << endl;
                    q.pop();
                }
                realtime += 5;
                goto here;

    }
    while (!q.empty()) {
        if (realtime >= t0)
            break;
        cout << q.top().second << endl;
        q.pop();
        realtime += 5;
    }
    return 0;

}
```



### 18118 勇者斗恶龙

时间限制:800MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC;VC



**Description**

```
有n个头的恶龙，你希望雇一些骑士把它杀死（即砍掉所有头）。村里有ｍ个骑士可以雇佣，一个能力值为x的骑士可以砍掉恶龙
一个直径不超过x的头，且需要支付x个金币。如何雇佣骑士才能砍掉恶龙的所有头，且需要支付的金币最少？注意，一个骑士只
能砍一个头（且不能被雇佣两次）
```



**输入格式**

```
多组数据，每组数据的第一行为正整数n和m(1<=n,m<=200000)；以下n行每行为一个整数，即恶龙每个头的直径；以下m行每行为
一个整数，即每个骑士的能力。输入结束标志ｎ＝ｍ＝0;
```



**输出格式**

```
输出格式：每组数据，输出最少花费，无解输出"Loowater is doomed!"
```



**输入样例**

```
2 3
5
4
7
8
4
2 1
5
5
10
0 0
```



**输出样例**

```
11
Loowater is doomed!
```



**分析**

这段代码实现了一个名为"Loowater"的问题的解决方案。这是一个经典的贪心算法问题。下面是对这段代码的分析：

1. 定义了两个全局变量`n`和`m`，分别表示龙头的数量和骑士的数量。
2. 定义了两个数组`ability`和`difficulty`，分别用于存储每个骑士的能力和每个龙头的难度。
3. `solve`函数是解决该问题的核心部分:
   - 首先输入龙头的难度和骑士的能力。
   - 然后将`difficulty`和`ability`数组分别排序。
   - 使用两个指针`i`和`j`分别遍历`ability`和`difficulty`数组。
   - 如果当前骑士的能力小于当前龙头的难度,则将指针`i`向前移动一位。
   - 如果当前骑士的能力大于等于当前龙头的难度，则将该骑士的能力累加到`amount`变量中，同时将两个指针都向前移动一位。
   - 最后,如果`j`没有到达`difficulty`数组的末尾，或者`n`大于`m`(即龙头数量大于骑士数量)，则输出"Loowater is doomed!"。否则输出总计金额`amount`。
4. `main`函数中,首先输入`n`和`m`的值。然后循环调用`solve`函数,直到输入的`n`和`m`都为0。

这个算法的核心思想是贪心地选择最小的能力值来击败当前最小难度的龙头。通过对`ability`和`difficulty`数组进行排序，可以确保每次选择的都是当前最优的选择。如果无法找到合适的骑士来击败某个龙头，则输出"Loowater is doomed!"。否则输出总计金额。

这个算法的时间复杂度为O(n log n + m log m)，主要由数组排序的时间开销决定。空间复杂度为O(n + m)，用于存储龙头的难度和骑士的能力。



**参考代码**

```cpp
#include<iostream>
#include<algorithm>

using namespace std;

int n, m;
int ability[200001];
int difficulty[200001];

void solve()
{
	int amount = 0;
	for (int i = 0; i < n; i++)
	{
		cin >> difficulty[i];
	}
	for (int i = 0; i < m; i++)
	{
		cin >> ability[i];
	}
	sort(difficulty, difficulty + n);
	sort(ability, ability + m);
	int i = 0, j = 0;
	while (i != m && j != n)
	{
		if (ability[i] < difficulty[j])
			i++;
		else
		{
			amount += ability[i]; i++; j++;
		}
	}
	if (j != n || n > m)
		cout << "Loowater is doomed!" << endl;
	else
		cout << amount << endl;
}

int main()
{
	cin >> n >> m;
	while (!(n == 0 && m == 0))
	{
		solve();
		cin >> n >> m;
	}
}
```



### 18107 校赛排名

时间限制:4000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC;VC



**Description**

```
校赛结束了，每一个参赛选手由3个数据项构成（通过题数，用时分钟数，姓名），排名按照通过题数排序
通过题数多的排前，同题数的，罚时少的排前。如果题数相同，罚时也相同，而按数据读取的先后排。
给你N个参赛选手的数据，按排序先后，输出姓名
```



**输入格式**

```
第一个数为N，（N<=500000）
此后，每行一个参赛选手的数据，通过题数，用时分钟数，姓名，前两者为整型数，姓名为字符串（不多于20个字符）
```



**输出格式**

```
姓名排名
```



**输入样例**

```
4
3 5 Jon
5 100 Smith
3 5 Tom
6 95 Hel
```



**输出样例**

```
Hel
Smith
Jon
Tom
```



**提示**

```
由于有500000个数据，输入和输出务必使用scanf和printf
```



**分析**

1. 定义了一个`Student`类,包含学生的编号`num`、最小成绩`min`和姓名`name`。
2. 定义了一个`stu`数组用于存储所有学生信息。
3. 定义了一个比较函数`cmp`,首先比较学生编号,如果编号相同则比较最小成绩。
4. 在`main`函数中,首先读入学生总数`n`。
5. 然后逐个读入每个学生的信息,存入`stu`数组。
6. 使用`stable_sort`函数,根据`cmp`函数的比较规则对`stu`数组进行排序。
7. 最后,依次输出排序后学生的姓名。



主要的算法思想是:

1. 首先根据学生编号进行排序,编号大的学生排在前面。
2. 如果编号相同,则根据最小成绩进行排序,最小成绩小的学生排在前面。
3. 排序使用`stable_sort`函数,保证了相同编号的学生保持原有的相对顺序。

这样可以实现按照学生编号从大到小,并且相同编号的学生按最小成绩从小到大的顺序排列。



**参考代码**

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

class Student {
public:
    int num;
    int min;
    char name[21];
};
Student stu[500001];
bool cmp(Student a, Student b) {
    if(a.num == b.num) return a.min < b.min;
    else return a.num > b.num;
}
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        scanf("%d %d %s", &stu[i].num, &stu[i].min, stu[i].name);
    }
    stable_sort(stu, stu + n, cmp);
    for (int i = 0; i < n; i++) {
        printf("%s\n", stu[i].name);
    }
}
```



## 3. 递归思想和分治

### 1142 巡逻的士兵

时间限制:1000MS 代码长度限制:10KB
提交次数:217 通过次数:58

题型: 编程题  语言: G++;GCC



**Description**

```
有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现要求统计按这样的方法，

总共可能有多少种不同的正好三个士兵去侦察的士兵组合方案。

注: 按上法得到少于三士兵的情况不统计。

1 <= N <= 2的32次方-1
```



**输入格式**

```
有多行（可能有上百行，尽量优化代码），每行一个数字N，最后一行是0
```



**输出格式**

```
对每一行的数字N，输出针对N的方案数

直到没有数字
```



**输入样例**


```
10
4
0
```



**输出样例**

```
2
0
```



**分析**

这段代码实现了一个名为 `f` 的递归函数,用于计算输入整数 `n` 的"最小因子和"。所谓"最小因子和",是指将 `n` 分解成几个最小的正整数相加的和。

具体来说,该算法的实现如下:

1. 如果 `n` 小于或等于 3,则返回特定值:
   - 如果 `n` 等于 3,返回 1。
   - 如果 `n` 小于 3,返回 0。
2. 如果 `n` 是偶数,则返回 `2 * f(n/2)`。
3. 如果 `n` 是奇数,则返回 `f(n/2) + f((n+1)/2)`。

在 `main` 函数中,程序会不断读取输入整数 `n`，并调用 `f(n)` 函数输出结果,直到输入 0 为止。

这个算法的时间复杂度是 O(log n)，因为每次递归调用都将问题规模减半。



**参考代码**

```cpp
#include <iostream>

using namespace std;

int F(int n) {
    if (n <= 0) { // 
        return 0;
    }
    if (n <= 3) { // 处理 1, 2, 3 的特殊情况
        return (n == 3) ? 1 : 0;
    }
    if (n % 2 == 0) { 
        return 2 * F(n / 2);
    } else { // 处理奇数情况
        return F(n / 2) + F((n + 1) / 2);
    }
}

int main() {
    int n;
    while (cin >> n && n) { // 读取输入,直到遇到 0
        cout << F(n) << endl;
    }
    return 0;
}
```



### 18441 偷懒的士兵

时间限制:1000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC;VC



**Description**

```
有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。
为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 
或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现有一个“聪明”的士兵，
经常通过选择站在合适的初始位置，成功避免被选中去侦察。这引起了陈教官的注意。陈教官希望你编写一个程序，
当给定士兵数之后，输出有多少个位置上的士兵是不可能被选中去巡逻的。

注: 按上法得到少于三士兵的情况不用去巡逻。

1 <= N <= 21亿
```



**输入格式**

```
有多行（可能有上百行，请尽量优化代码），每行一个数字N，最后一行是0
```



**输出格式**

```
对每一行的数字N，不可能被选中去巡逻的位置数

直到没有数字
```



**输入样例**

```
10
6
0
```



**输出样例**

```
4
0
```



**分析**

总体上，该代码与上到例题一致，具体差异体现在返回值上。

1. 如果 `n` 小于或等于 3,则返回特定值:

   - 如果 `n` 等于 3,返回 1。

   - 如果 `n` 小于 3,返回 n。

     因为返回值 `n` 表示不用去巡逻的士兵数，所以当递推终止，向上循环时，`n == 1 || n == 2` 

     

2. 如果 `n` 是偶数,则返回 `2 * f(n/2)`。

3. 如果 `n` 是奇数,则返回 `f(n/2) + f((n+1)/2)`。

4. **通过上一个状态的公式，累加求和即可以得到总的不用去巡逻的士兵数。**





**参考代码**

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int F(int n) {
    if (n <= 0) { // 
        return 0;
    }
    if (n <= 3) {
        return (n == 3) ? 0 : n;
    }
    if (n % 2 == 0) { 
        return 2 * F(n / 2);
    } else { // 处理奇数情况
        return F(n / 2) + F((n + 1) / 2);
    }
}

int main()
{
    int n;

    while((cin>>n) && n)
    {
        cout << F(n) << endl;
    }

    return 0;
}
```



### 18442 偷懒的士兵2

时间限制:1000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC;VC



**Description**

```
有N个士兵站成一队列, 现在需要选择几个士兵派去侦察。
为了选择合适的士兵, 多次进行如下操作: 如果队列超过三个士兵, 那么去除掉所有站立位置为奇数的士兵, 
或者是去除掉所有站立位置为偶数的士兵。直到不超过三个战士，他们将被送去侦察。现有一个“聪明”的士兵，
经常通过选择站在合适的初始位置，成功避免被选中去侦察。这引起了陈教官的注意。陈教官希望你编写一个程序，
当给定士兵数之后，输出不可能被选中去巡逻的最少编号位置（如果不存在不可能被选中的位置，则输出0）。

注: 按上法得到少于三士兵的情况不用去巡逻。

1 <= N <= 100000
```



**输入格式**

```
有多行（不多于20行），每行一个数字N，最后一行是0
```

**输出格式**

```
对每一行的数字N，不可能被选中去巡逻的最小位置

直到没有数字
```



**输入样例**

```
9
6
0
```



**输出样例**

```
2
0
```



**分析**

与上述偷懒的士兵1 相比，这道题最大的难点在于如何利用有效的时间空间记录偷懒的士兵的位置值；


通过分析可以发现，该题目具有一定规律性。

1. 索引 `index` 即为向上递归时的最小数组的首数值；
2. 间距 `distance` 即为最小数组的元素间距；



通过以上规律，我们可以构造一个函数 `F(int n, int index, int distance)`

该函数在每次调用时，更新 `index` 和 `distance` ，以确保最后可以直接返回`index` 值。



最后通过`min`函数比较，得到的 `index` 值即为不可能被选中去巡逻的最少编号位置。



**参考代码**

```cpp
#include <iostream>
#include <algorithm>
 
using namespace std;
 
int F(int n,int index,int distance)
{
    if(n == 3)
        return 0;
    if(n < 3)
        return index;
    else
    {
        //去偶
        int a = F((n + 1)/ 2, index, distance * 2);
        //去奇
        int b = F(n / 2, index + distance, distance * 2);
        
        if(a && b)
            return min(a, b);
        else if(a)
            return a;
        else if(b)
            return b;
    }
}
 
int main()
{
    int n;
    while(cin >> n && n)
    {
        cout << F(n, 1, 1) <<endl;
    }
    return 0;
}
```



## 4. 枚举的技巧

### 18443 除法等式

**Description**



```
输入正整数n,按从小到大的顺序输出所有形如abcde/fghij=n的表达式，其中a~j各代表0~9中的一个数字
除了0可以重复外，其它数字不能重复，2<=n<=90000。
```



**输入格式**

```
多case，每行一个数字，最后一个数字是0
```



**输出格式**

```
除了最后一行0不用处理，
其它每个case，按被除数由小到大输出所有满足等式的情况
注：如果没有满足条件的等式，该case结束后，也需要输出一个空行

两个case之间用一个空行分隔
```



**输入样例**

```
44
666
6666
20000
0
```



**输出样例**

```
00176/00004=44
00308/00007=44
00352/00008=44
...
95348/02167=44
95480/02170=44

27306/00041=666
41958/00063=666
...
53946/00081=666
63270/00095=666


20000/00001=20000
40000/00002=20000
60000/00003=20000
80000/00004=20000
```



**参考代码**

```cpp
#include<iostream>
using namespace std;

// 判断两个数字是否每一位都是唯一的
bool areDigitsUnique(int num1, int num2) {
    int digitCount[10] = {0}; // 记录每个数字的出现次数
    
    while (num1) {
        digitCount[num1 % 10]++; // 记录 num1 的每一位出现的次数
        num1 /= 10;
    }
    
    while (num2) {
        digitCount[num2 % 10]++; // 记录 num2 的每一位出现的次数
        num2 /= 10;
    }
    
    for (int i = 1; i < 10; i++) { // 检查 1 到 9 是否有重复的数字
        if (digitCount[i] > 1) return false; // 如果有重复，返回 false
    }
    return true; // 如果没有重复，返回 true
}

int main() {
    int caseNumber;
    cin >> caseNumber;
    
    while (caseNumber) {
        for (int denominator = 1; denominator <= 50000; denominator++) { // 枚举所有可能的分母
            int numerator = denominator * caseNumber;
            if (numerator > 0 && numerator <= 98765) { // 检查乘积是否在有效范围内
                if (areDigitsUnique(numerator, denominator)) { // 检查两个数字的每一位是否没有重复
                    printf("%05d/%05d=%d\n", numerator, denominator, caseNumber); // 输出符合条件的表达式
                }
            }
        }
        cout << endl; // 输出空行
        cin >> caseNumber; // 读取下一个输入
    }
    
    return 0;
}
```



### 1079 三角形

**Description**

```
著名的数学家毕达哥拉斯可能从来都不曾想过有人居然会问他这样的一个问题：给出一个整数，存在多少个直角三角形，
它的某一条边的长度等于这个整数，而且其他边的长度也是整数。既然毕达哥拉斯不可能预见到有计算机的出现，
如果他回答不出来，那谁又能责怪他呢？但是现在既然你有了计算机，那么回答不出来就说不过去了。
```



**输入格式**

 第一行有一个整数n，代表有多少个数据（1<=n<=20）。接下来有n行，每行代表一个数据。一个数据就是一个整数ai(a<=i<=n，1<=ai<=100)。



**输出格式**

```
每个数据都必须有相应的输出。两个数据的输出之间有一个空行。
对于每一个数据，如果找不到解，则输出一个空行。如果找到解，就把符合条件的所有直角三角形输出。每个三角形占一行，输出该三角形的另外两条边，
必须先输出长边，然后一个逗号，再输出短边。两个三角形之间不能有空行，而且必须按照长边降序排列。
```



**输入样例**

```
2
20
12
```



**输出样例**

```
101,99
52,48
29,21
25,15
16,12

37,35
20,16
15,9
13,5
```



**参考代码1**

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

void findPythagoreanPairs() {
    int number;
    cin >> number;

    // 遍历 b 大于 number 的所有值，找到满足条件的 a 和 b
    for (int b = 2501; b > number; b--) {
        int a = sqrt(b * b - number * number);
        if ((a * a + number * number == b * b) && b > a) {
            cout << b << "," << a << endl;
        }
    }

    // 遍历小于 number 的所有值，找到满足条件的 m 和 n
    for (int m = number - 1; m > 0; m--) {
        int n = sqrt(number * number - m * m);
        if ((n * n + m * m == number * number) && m >= n) {
            cout << m << "," << n << endl;
        }
    }
    cout << endl; // 输出空行
}

int main() {
    int testCases;
    cin >> testCases;

    while (testCases--) {
        findPythagoreanPairs();
    }
    return 0;
}
```



### 8623 龙龙

**Description**

```
在比赛的时候，1Y(1 次AC)是很值得高兴的事情。但很多大牛总会因为很弱智的错误先WA 一次，再AC。
而很多时候，这点罚时的差距使得他们与金牌无缘。弱智错误系列中最显著的就是忘记加龙龙。

龙龙外国人叫它作long long，表示64位整数，输入与输出64位整数则可以使用例如
scanf("%lld", &a)与printf("%lld", a)的形式完成。很多图论和动态规划的题目中，
虽然题目说最后输出的答案是32 位的整数，但中间计算的过程有时会超过int，这时我们就要使用龙龙了。

可惜的是，很多同学刚开始学写程序都是用VC的，在VC上是无法使用long long的，我们要用__int64
代替，输入与输出64位整数则可以使用例如scanf("%I64d", &a)与printf("%I64d", a)的形式完成。


但是提交上OJ 的时候，如果使用GCC或G++，都只支持long long，我们在提交时又得按照上边的改回来（的确挺麻烦,窘）。
为了让知道龙龙的同学们记得使用龙龙，不知道的学习使用龙龙，下边有个很简单的函数，希望大家
求出它的返回值：

long long H(int n){
    long long res = 0;
    int i;
    for(i = 1; i <= n; i=i+1 ){
        res = (res + n/i);
    }
    return res;
}

不过直接使用这个函数是会超时的，必须改造这个函数，当然这一定难不到未来的编程高手--你
```



**输入格式**

```
第一行是数字T(T<=1021)表示case数，接下来T 行，每行一个整数n，n是一个32 位整数（保证可以由int 表示）。
```



**输出格式**

```
函数返回值。
```



**输入样例**

```
2
5
10
```



**输出样例**

```
10
27
```



**分析**

为了处理这道题，我们需要优化原始的函数 `H(int n)`，因为直接按 `H(n)` 的定义计算时会超时。该问题的核心在于计算以下和：
$$
 H(n) = \sum_{i=1}^{n} \left\lfloor \frac{n}{i} \right\rfloor 
$$
直接计算每一个 $\left\lfloor \frac{n}{i} \right\rfloor$ 是非常耗时的，因此我们需要优化算法。

可以分为两个部分进行计算：

1. 当 `i` 较小时，直接计算 `n / i`。
2. 当 `i` 较大时，利用分段和的方法。

为了优化计算，我们可以利用数论中的分段思想。具体步骤如下：

- 对于 `i` 从 1 到 `sqrt(n)`，直接计算 `n / i` 并累加到结果中。
- 对于 `k` 从 1 到 `sqrt(n)`，考虑 `v` 从 `n // (k+1)` 到 `n // k`（不重复计算），每一段的 $\left\lfloor \frac{n}{v} \right\rfloor$为常数 `k`，每段的长度为 `v` 的区间长度。

这样，时间复杂度可以降低到 `O(sqrt(n))`。



**参考代码**

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    long long int Cases, caseIdx, currentNum, j, squareRoot, upper, lower, result = 0;
    
    // 读取测试用例的数量
    cin >> Cases;
    
    for (caseIdx = 0; caseIdx < Cases; caseIdx++) {
        result = 0;
        
        // 读取当前测试用例的数值
        cin >> currentNum;
        
        // 计算当前数值的平方根
        squareRoot = sqrt(currentNum);
        
        // 计算第一部分的和：从 1 到 n/(sq+1)
        for (j = 1; j <= currentNum / (squareRoot + 1); j++) {
            result += currentNum / j;
        }
        
        upper = currentNum;
        
        // 计算第二部分的和：从 1 到 sq
        for (j = 1; j <= squareRoot; j++) {
            lower = currentNum / (j + 1);
            result += j * (upper - lower);
            upper = lower;
        }
        
        // 输出结果
        cout << result << endl;
    }
    
    return 0;
}

```



### 18444 分数拆分

时间限制:2500MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC;VC



**Description**

```
输入正整数k（k<=1000），将1/k变为不少于2项，但不多于3项的1/(xi)之和，xi为正整数，且i表示序号

注：请使用long long
```



**输入格式**

```
多case，一行一个整数k

最后一行是0
```



**输出格式**

```
对每一个case，按等式最右边一项分母，由小到大排序输出满足条件的等式，最右边一项分母相同，则按最右边第二项，依次类推

每一个case完成后，输出一个空行（没有满足的等式时，也要输出该空行）
```



**输入样例**

```
2
3
4
0
```



**输出样例**

```
1/2=1/6+1/3
1/2=1/42+1/7+1/3
1/2=1/24+1/8+1/3
1/2=1/18+1/9+1/3
1/2=1/15+1/10+1/3
1/2=1/12+1/12+1/3
1/2=1/4+1/4
1/2=1/20+1/5+1/4
1/2=1/12+1/6+1/4
1/2=1/8+1/8+1/4
1/2=1/10+1/5+1/5
1/2=1/6+1/6+1/6

1/3=1/12+1/4
1/3=1/156+1/13+1/4
1/3=1/84+1/14+1/4
1/3=1/60+1/15+1/4
1/3=1/48+1/16+1/4
1/3=1/36+1/18+1/4
1/3=1/30+1/20+1/4
1/3=1/28+1/21+1/4
1/3=1/24+1/24+1/4
1/3=1/120+1/8+1/5
1/3=1/45+1/9+1/5
1/3=1/30+1/10+1/5
1/3=1/20+1/12+1/5
1/3=1/15+1/15+1/5
1/3=1/6+1/6
1/3=1/42+1/7+1/6
1/3=1/24+1/8+1/6
1/3=1/18+1/9+1/6
1/3=1/15+1/10+1/6
1/3=1/12+1/12+1/6
1/3=1/21+1/7+1/7
1/3=1/12+1/8+1/8
1/3=1/9+1/9+1/9

1/4=1/20+1/5
1/4=1/420+1/21+1/5
1/4=1/220+1/22+1/5
1/4=1/120+1/24+1/5
1/4=1/100+1/25+1/5
1/4=1/70+1/28+1/5
1/4=1/60+1/30+1/5
1/4=1/45+1/36+1/5
1/4=1/40+1/40+1/5
1/4=1/12+1/6
1/4=1/156+1/13+1/6
1/4=1/84+1/14+1/6
1/4=1/60+1/15+1/6
1/4=1/48+1/16+1/6
1/4=1/36+1/18+1/6
1/4=1/30+1/20+1/6
1/4=1/28+1/21+1/6
1/4=1/24+1/24+1/6
1/4=1/140+1/10+1/7
1/4=1/42+1/12+1/7
1/4=1/28+1/14+1/7
1/4=1/8+1/8
1/4=1/72+1/9+1/8
1/4=1/40+1/10+1/8
1/4=1/24+1/12+1/8
1/4=1/16+1/16+1/8
1/4=1/36+1/9+1/9
1/4=1/18+1/12+1/9
1/4=1/20+1/10+1/10
1/4=1/15+1/12+1/10
1/4=1/12+1/12+1/12
```



**参考代码**

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int main() {
    long long x, y, z, k;
    while (cin >> k && k) { // 不断读取输入，直到输入为0为止
        for (z = k + 1; z <= 3 * k; z++) { // 遍历 z，z的取值范围是[k+1, 3k]
            y = k * z / (z - k); // 根据公式计算 y
            if ((k * z) % (z - k) == 0 && y >= z) // 检查是否满足条件
                printf("1/%lld=1/%lld+1/%lld\n", k, y, z);

            int p = k * z / (z - k); // 计算p
            for (y = p + 1; y <= 2 * p + 1; y++) { // 遍历y，y的取值范围是[p+1, 2p+1]
                x = k * y * z / (y * z - k * z - k * y); // 根据公式计算x
                if ((k * y * z) % (y * z - k * z - k * y) == 0 && x >= y && y >= z) // 检查是否满足条件
                    printf("1/%lld=1/%lld+1/%lld+1/%lld\n", k, x, y, z); // 输出结果
            }
        }
        printf("\n"); // 输出空行
    }
    return 0;
}

```



## 5. 搜索算法

### 18124 N皇后问题

时间限制:5000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: G++;GCC;VC



**Description**

```
有N*N的国际象棋棋盘，要求在上面放N个皇后，要求任意两个皇后不会互杀，有多少种不同的放法？
```



**输入格式**

```
每一个数为T，代表CASE的数量，T<=13
此后，每行一个数N（13>=N>0）
```



**输出格式**

```
每一个CASE，输出对应答案
```



**输入样例**

```
2
4
5
```



**输出样例**

```
2
10
```



**参考代码**

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAX_N = 13; // 最大棋盘大小
int cnt; // 解决方案计数器
bool col[MAX_N], diag1[2 * MAX_N], diag2[2 * MAX_N]; // 用于标记当前行、主对角线和次对角线是否已经放置了皇后

void backtrack(int n, int r) {
    // 如果已经到达最后一行,说明找到了一个解决方案
    if (r == n) {
        cnt++;
        return;
    }

    // 尝试在当前行的每一列放置皇后
    for (int c = 0; c < n; c++) {
        // 如果当前位置合法(不在同一行、主对角线和次对角线上)
        if (!col[c] && !diag1[r + c] && !diag2[r - c + n - 1]) {
            // 标记当前位置已经放置了皇后
            col[c] = diag1[r + c] = diag2[r - c + n - 1] = true;
            // 递归尝试下一行
            backtrack(n, r + 1);
            // 回溯,撤销当前位置的皇后
            col[c] = diag1[r + c] = diag2[r - c + n - 1] = false;
        }
    }
}

int main() {
    int T;
    cin >> T; // 输入测试用例数

    while (T--) {
        int n;
        cin >> n; // 输入棋盘大小
        cnt = 0; // 重置解决方案计数器
        memset(col, false, sizeof(col)); // 重置标记数组
        memset(diag1, false, sizeof(diag1));
        memset(diag2, false, sizeof(diag2));
        backtrack(n, 0); // 从第0行开始尝试放置皇后
        cout << cnt << endl; // 输出解决方案数量
    }

    return 0;
}
```



### 19010 最小的特殊数字

**Description**

```
用全部N(N<=10)个0-9的数字组成一个“有效”整数（即没有前置0的整数），
求这些组成的数中能被K(0<K<10^10)整除的最小数字。
```



**输入格式**

```
输入分两行，第一行输入N, K，第二行输入N个数字。
```



**输出格式**

```
输出满足条件的最小的数（不含前置0），如果没有满足条件的数输出 -1。
```



**输入样例**

```
4 7
4 0 1 3
```



**输出样例**

```
1043
```



**提示**

```
413 % 7 = 0， 但是有前置0，所以满足条件的最小数是 1043 % 7 = 0。
此类题目需注意特殊情况，比如n=1时,如只输入一个0，答案只能是0。
注意long long
```



**参考代码**

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL; // 定义 LL 作为 long long 的别名,方便后续使用

bool visited[15]; // 记录每个数字是否已经被使用

int numDigits; // 输入的数字个数
LL divisor; // 需要被整除的数

int digits[15]; // 存储输入的数字

vector<LL> validNumbers; // 存储满足条件的数字

// 计算一个数字的位数
int getNumDigits(int num) {
    if (!num) return 1; // 特殊情况: 0 的位数为 1
    int count = 0;
    while (num) {
        num /= 10;
        count++;
    }
    return count;
}

// 深度优先搜索递归函数
void dfs(int index, LL currentNum) {
    if (index == numDigits) { // 已经构建了一个完整的数字
        // 如果这个数字能被 divisor 整除,并且位数等于输入的数字个数,则记录下来
        if (currentNum % divisor == 0 && getNumDigits(currentNum) == numDigits) {
            validNumbers.push_back(currentNum);
        }
    }

    // 尝试每一个可用的数字
    for (int i = 0; i < numDigits; i++) {
        if (!visited[i]) { // 如果这个数字还没被使用
            visited[i] = true; // 标记为已使用
            dfs(index + 1, currentNum * 10 + digits[i]); // 递归构建下一个数字
            visited[i] = false; // 重置为未使用状态
        }
    }
}

int main() {
    cin >> numDigits >> divisor; // 输入数字个数和需要被整除的数

    for (int i = 0; i < numDigits; i++) {
        cin >> digits[i]; // 输入数字
    }

    memset(visited, false, sizeof(visited)); // 初始化所有数字为未使用状态

    dfs(0, 0); // 从空串开始递归构建数字

    sort(validNumbers.begin(), validNumbers.end()); // 对结果排序

    cout << validNumbers[0]; // 输出最小的满足条件的数字
}
```



## 6. 动态规划算法

### 8615 快乐

**Description**

```
Lian是一个喜欢看动画片的人，自从成为ACMer（ACM爱好者）之后，他又迷上了网上做题。做题让他快乐，不过这也是需要付出精力的！！
假设有n道题，Lian做出第i道题后，他可以获得的快乐指数将增加gethappy[i]，而消耗掉的精力将是losspow[i]。
假设Lian初始的快乐指数为1，精力为2000。可以理解，如果他消耗完了所有的精力那他得到再多的快乐都没有用。
你的任务就是帮他计算他所能得到的最多的快乐指数，且最后他依然有多余的精力（即至少为1）。
```



**输入格式**

```
第一行输入一个整数n，表示有n道题。(n<=50)
第二行输入n个整数，表示gethappy[1]到gethappy[n]
第三行输入n个整数，表示losspow[1]到losspow[n]。
```



**输出格式**

```
一个整数，表示Lian所能获得的最大快乐指数。
```



**输入样例**

```
3
15 23 61
350 1301 1513
```



**输出样例**

```
77
```



**参考代码**

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;

const int N=55;

int gethappy[N],losspow[N];

int f[2010];

int n, m=1999;

int main()
{
	cin>>n;
	
	for(int i=1;i<=n;i++)
        cin>>gethappy[i];
    
	for(int i=1;i<=n;i++)
        cin>>losspow[i];
	
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=losspow[i];j--)
		{
			f[j] = max(f[j], f[j-losspow[i]] + gethappy[i]);
		}
	}
	
	cout<<f[m]+1;
} 
```



### 18705 01背包问题

时间限制:1000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: 不限定



**Description**

```
有一个容积为M的背包和N件物品。第i件物品的体积W[i]，价值是C[i]。求解将哪些物品装入背包可使价值总和最大。每种物品只有一件，
可以选择放或者不放入背包。
```



**输入格式**

```
第一行：两个整数，M(背包容量，M<=200)和N(物品数量，N<=30)；
第2..N+1行：每行二个整数Wi，Ci，表示每个物品的重量和价值。
```



**输出格式**

```
一个数，表示最大总价值。
```



**输入样例**

```
10 4
2 1
3 3
4 5
7 9
```



**输出样例**

```
12
```



**参考代码**

```cpp
#include <iostream>

using namespace std;

const int N=1010;

int n,m;

int f[N],w[N],v[N];

int main()
{
    cin>>m>>n;
    
    for(int i=1;i<=n;i++)cin>>v[i]>>w[i];
    
    f[0]=0;
    for(int i=1;i<=n;i++)
        for(int j=m;j>=v[i];j--)
            f[j]=max(f[j], f[j-v[i]]+w[i]);
    cout<<f[m]<<endl;
}
```



### 19523 最长上升子序列长度

时间限制:1000MS 代码长度限制:10KB
提交次数:0 通过次数:0

题型: 编程题  语言: 不限定



**描述**

```
当元素 ai1 < ai2 < … < aiK. 就说这个序列是有序上升的。

给定序列(a1, a2, …, aN)，存在许多这样的子序列(ai1, ai2, …, aiK)，
其中1 <= i1 < i2 < … < iK <= N.
也就是说，子序列是原序列允许挑选若干不连续的元素形成的序列。

举个例子，序列 (1, 7, 3, 5, 9, 4, 8) 就有许多个上上子序列，比如(1, 7), (3, 4, 8) 等。
所有这些上升子序列中最长的长度为4，比如 (1, 3, 5, 8).

你来编程实现，当给定一个初始序列，求解这个序列的最长上升子序列的长度。
```



**输入格式**

此例包含多个测试cases（少于100组test cases）。
每一组test case包含2行。
第一行是这组case的序列长度 N。（N的范围0~10000）
第二行包含 N个整数的一个序列，用空格间隔这N个整数， 1 <= N <= 10000。
当N为0时，表示测试结束。

**输出格式：**

输出必须对每个test case，都有一个整数结果，表示这组case的最长上升子序列的长度。



**输入样例：**

```
7
1 7 3 5 9 4 8
6
1 8 3 6 5 9
5
1 2 3 4 5
0
```



**输出样例：**

```
4
4
5
```



**参考代码**

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N=1e5+10;

int a[N],q[N];

int main()
{
    int n;
    
    while(cin>>n,n)
    {
        memset(q,0,sizeof q);
        for(int i=0;i<n;i++)cin>>a[i];
        
        q[0]=a[0];
        int cnt=0;
        for(int i=1;i<n;i++)
        {
            if(a[i]>q[cnt])q[++cnt]=a[i];
            else
            {
                int l=0,r=cnt;
                while(l<r)
                {
                    int mid=l+r>>1;
                    if(q[mid]>=a[i])r=mid;
                    else l=mid+1;
                }
                q[r]=a[i];
            }
        }
        
        cout<<cnt+1<<'\n';
    }
}
```



### 18308 最长公共子序列长度

**Description**

```
给定两个字符串，请输出这两个字符串的最大公共子序列
```



**输入格式**

```
两行，一行一个字符串（不包括空格，Tab键）,长度不超过1000
```



**输出格式**

```
输出最大公共子序列的长度
```



**输入样例**

```
abbca
aba
```



**输出样例**

```
3
```



**参考代码**

```cpp
#include <iostream>
#include <string.h>
using namespace std;
const int N=1010;
int n,m;
char a[N],b[N];
int f[N][N];
int main()
{
    scanf("%s%s",a+1,b+1);
    n=strlen(a+1),m=strlen(b+1);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            if(a[i]==b[j])
            {
                f[i][j]=max(f[i][j],f[i-1][j-1]+1);
            }
        }
    }
    printf("%d",f[n][m]);
}
```



## 7. 并查集和树状数组

### 18233 万湖之国的形成

**Description**

```
N国原是一块平原上，没有湖，直到一颗小行星撞入大气层碎成成千上万的碎片，碎片再撞击地面形成
一个一个的坑， 下雨之后，最终形成万湖之国。
现在科学家想用计算机模拟万湖之国形成过程，假设每一块碎片撞击地面，都撞出一个园形坑，现在知道
每一个碎片造成的坑的圆心和半径，问每个坑都注满水后，最终形成多少个湖？
```



**输入格式**

```
第一行一个整数N，1<=N<=100,000，表示坑的数量
此后N行，每一行三个double实数，前两个数是圆心的坐标x和y，最后一个数是圆半径（不大于1000）
(数据随机产生，分布均匀)
```



**输出格式**

```
湖的个数
```



**输入样例**

```
3
0 0 5
10 0 5
11.1 0 2.5
```



**输出样例**

```
2
```



**参考代码**

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 1e5 + 10; // 设置最大圆的数量

int p[N]; // 并查集数组

// 并查集查找根节点操作
int find(int x) {
    if (x != p[x]) return p[x] = find(p[x]); // 路径压缩
    return p[x];
}

// 定义一个结构体表示圆形物体
struct Edge {
    double x, y, r; // 圆心坐标 (x, y)，半径 r
} edges[N];

// 自定义比较函数，按照圆心 x 坐标从小到大排序
bool mycmp(Edge A, Edge B) {
    return A.x - A.r < B.x - B.r;
}

int main() {
    int n;
    cin >> n; // 输入圆形物体的数量

    // 初始化并查集
    for (int i = 1; i <= n; i++) p[i] = i;

    // 输入圆形物体的信息
    for (int i = 1; i <= n; i++) {
        double x, y, r;
        cin >> x >> y >> r;
        edges[i] = {x, y, r}; // 存储圆形物体的信息
    }

    // 按照自定义比较函数排序
    sort(edges + 1, edges + 1 + n, mycmp);

    int ans = n; // 初始化答案为圆形物体的数量

    // 枚举每个圆形物体
    for (int i = 1; i + 1 <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            auto a = edges[i], b = edges[j]; // 取出两个圆形物体
            if (a.x + a.r <= b.x - b.r) break; // 如果两个圆形物体不可能相交，则跳出内层循环

            // 计算两个圆形物体的圆心距离
            if (sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) < a.r + b.r) {
                // 如果两个圆形物体相交，则合并它们所在的连通分量
                int a1 = find(i), b1 = find(j);
                if (a1 == b1) continue; // 如果已经在同一个连通分量中，则跳过
                ans--; // 否则，答案减 1
                p[a1] = b1; // 合并两个连通分量
            }
        }
    }

    cout << ans; // 输出答案

    return 0;
}
```



### 18130 繁忙的公路

**Description**

```
在一条笔直的大道（单方向行车道）上，汽车川流不息。道路从起点到终点，等距离的标记了1到N，
即起点是1，然后分别是2、3、4.....，终点是N。每一个标记处，安装了智能探头，可以感知
在该点处车辆的增减数量。
一开始，整条道路上，没有车，然后，是不断接收到的智能探头发回的信息，格式如下：
H 5 9
H表明收到的是智能探头的回传信息，5表示标记5处的车辆信息，9表示该处车辆增加了9辆。
同时，在某个时刻，需要查询在一段连续的道路上，共有多少辆车
查询格式如下：
Q 3 10
Q表明收到的是查询，3是起点，10是终点（包括3和10两处）
要求编程实现正确处理上述信息处理和查询
```



**输入格式**

```
第一行一个整数N（1<=N<=1,000,000），表示标记范围是1到N
第二行一个整数M（1<=M<=100,000），表示探头信息（或查询）的总数量
此后M行，每行一个探头信息或查询请求
```



**输出格式**

```
每逢遇到查询的时候，输出查询范围内的有多少辆车，占一行，查询结果最大不超过2的63次方
```



**输入样例**

```
10
4
H 5 10
Q 1 10
H 6 20
Q 1 10
```



**输出样例**

```
10
30
```



**提示**

```
开始时，整条路上没有车辆
```



树状数组

 ```cpp
 #include <iostream>
 #include <cstring>
 #include <cmath>
 
 using namespace std;
 
 typedef long long LL; // 定义 long long 类型的别名 LL
 
 const int N = 1e7 + 10; // 树状数组的最大大小
 
 int tr[N]; // 树状数组,存储区间数据
 
 // 计算 x 的二进制表示中最低位的 1 及其右边的 0 组成的数
 int lowbit(int x) {
     return x & (-x);
 }
 
 // 将 c 加到树状数组中从 x 开始的所有区间上
 void add(int x, int c) {
     for (int i = x; i < N; i += lowbit(i))
         tr[i] += c;
 }
 
 // 查询从 1 到 x 的区间和
 LL ask(int x) {
     LL res = 0;
     for (int i = x; i; i -= lowbit(i))
         res += tr[i];
     return res;
 }
 
 int main() {
     int n, m;
     cin >> n >> m; // 输入数组长度和操作次数
 
     string op;
     int x, c;
     while (m--) {
         cin >> op >> x >> c; // 输入操作类型和参数
         if (op == "H") add(x, c); // 单点修改操作
         else printf("%d\n", ask(c) - ask(x - 1)); // 区间查询操作
     }
 }
 ```

