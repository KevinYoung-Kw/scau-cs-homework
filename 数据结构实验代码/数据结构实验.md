# File: 2022-2023 Academic Year SCAU Software Engineering Major Data Structures Lab Exercise Repository

[TOC]



##### **8576	顺序线性表的基本操作** 

```c++
#include<stdio.h>
#include<malloc.h>
#define OK 1
#define ERROR 0
#define LIST_INIT_SIZE 100
#define LISTINCREMENT 10
#define ElemType int

typedef struct
{
    int *elem;
    int length;
    int listsize;
} SqList;

int InitList_Sq(SqList &L)
{
// 算法2.3，构造一个空的线性表L，该线性表预定义大小为LIST_INIT_SIZE
// 请补全代码
    L.elem = new ElemType[LISTINCREMENT];
    if (!L.elem)
        return false;
    L.listsize = LISTINCREMENT;
    L.length = 0;
    return true;
}

int Load_Sq(SqList &L)
{
// 输出顺序表中的所有元素
    int i;
    if(L.length == 0) printf("The List is empty!");  // 请填空
    else
    {
        printf("The List is: ");
        for(int i = 0; i < L.length; i++) printf("%d ",L.elem[i]);  // 请填空
    }
    printf("\n");
    return OK;
}

int ListInsert_Sq(SqList &L,int i,int e)
{
// 算法2.4，在顺序线性表L中第i个位置之前插入新的元素e
// i的合法值为1≤i≤L.length +1
// 请补全代码
    if (i < 1 || i > L.length + 1 || L.length == L.listsize)
        return false;

    int j;
    for (j = L.length - 1; j >= i -1; j--)
        L.elem[j + 1] = L.elem[j];
    L.elem[i - 1] = e;
    L.length++;
    return true;
}

int ListDelete_Sq(SqList &L,int i, int &e)
{
// 算法2.5,在顺序线性表L中删除第i个位置的元素，并用e返回其值
// i的合法值为1≤i≤L.length
// 请补全代码
    if (i < 1 || i > L.length || L.length == 0)
        return false;

    e= L.elem[i - 1];

    for (int j = i - 1; j <= L.length - 2; j++)
        L.elem[j] = L.elem[j + 1];
    L.length--;
    return true;
}

int main()
{
    SqList T;
    int a, i;
    ElemType e, x;
    if(InitList_Sq(T))    // 判断顺序表是否创建成功
    {
        printf("A Sequence List Has Created.\n");
    }
    while(1)
    {
        printf("1:Insert element\n2:Delete element\n3:Load all elements\n0:Exit\nPlease choose:\n");
        scanf("%d",&a);
        switch(a)
        {
        case 1:
            scanf("%d%d",&i,&x);
            if(!ListInsert_Sq(T, i, x)) printf("Insert Error!\n"); // 执行插入函数，根据返回值判断i值是否合法
            else printf("The Element %d is Successfully Inserted!\n", x);
            break;
        case 2:
            scanf("%d",&i);
            if(!ListDelete_Sq(T, i, e)) printf("Delete Error!\n"); // 执行删除函数，根据返回值判断i值是否合法
            else printf("The Element %d is Successfully Deleted!\n", e);
            break;
        case 3:
            Load_Sq(T);
            break;
        case 0:
            return 1;
        }
    }
}

```

易错点

1. 没有充分初始化线性表，譬如表的长度和容量；

2. 插入和删除时没有考虑表满和表空的情况；

3. 插入和删除时要记得修改L. length；

4. 在调用函数时使用错误的变量，譬如把x使用成e；

   

##### **8577	合并顺序表** 

```C++
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;
int main(void)
{
    int * a, * b;
    vector<int> c;
    int n, k = 0;

    scanf("%d", &n);
    a = new int[n+1];

    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        c.push_back(a[i]);
        k++;
    }
    a[0] = n;

    scanf("%d", &n);
    b = new int[n+1];

    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &b[i]);
        c.push_back(b[i]);
        k++;
    }

    sort(c.begin(), c.end());

    printf("List A:");
        for (int i = 1; i <= a[0]; i++)
            printf("%d ", a[i]);
        printf("\n");

    printf("List B:");
        for (int i = 1; i <= a[0]; i++)
            printf("%d ", b[i]);
        printf("\n");

    printf("List C:");
        for (int i = 0; i < c.size(); i++)
            printf("%d ", c[i]);


    return 0;
}
```

备注：用了最简单的方式过，没有按照题目的要求。

1. 调用了STL库中的<vector>、<algorithm>库和sort的函数；

   

##### **8578	顺序表逆置**

```C++

#include <cstdio>

int main(void)
{
    int * a;
    int n;
    scanf("%d", &n);

    a = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);

    printf("The List is:");
    for (int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");

    printf("The turned List is:");
    for (int i = n - 1; i >= 0; i--)
        printf("%d ", a[i]);
    return 0;
}
```

备注：用了最简单的方式过，没有按照题目的要求。



##### **8579	链式线性表的基本操作** 

```C++
#include<stdio.h>
#include<malloc.h>
#define ERROR 0
#define OK 1
#define ElemType int

typedef struct LNode
{
    int data;
    struct LNode *next;
}LNode,*LinkList;

int CreateLink_L(LinkList &L,int n){
// 创建含有n个元素的单链表
  LinkList p,q;
  int i;
  ElemType e;
  L = new LNode;
  L->next = NULL;              // 先建立一个带头结点的单链表
  q = L;
  for (i=0; i<n; i++) {
    scanf("%d", &e);
    p = new LNode;
    p->data= e;
    p->next = NULL;
    q->next = p;
    q = p;
  // 生成新结点
    // 请补全代码
  }
  return OK;
}

int LoadLink_L(LinkList &L){
// 单链表遍历
 LinkList p = L->next;
 if(!p)
     printf("The List is empty!"); // 请填空
 else
 {
	 printf("The LinkList is:");
	 while(p)    // 请填空
	 {
		printf("%d ",p->data);
		p = p->next;    // 请填空
	 }
 }
 printf("\n");
 return OK;
}

int LinkInsert_L(LinkList &L,int i,ElemType e){
// 算法2.9
// 在带头结点的单链线性表L中第i个位置之前插入元素e
// 请补全代码
    LinkList p = L, s;
    int j = 0;
    while (p && j < i - 1)
    {
        p = p->next;
        j++;
    }

    if (!p || j > i - 1)
        return false;

    s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}

int LinkDelete_L(LinkList &L,int i, ElemType &e){
// 算法2.10
// 在带头结点的单链线性表L中，删除第i个元素，并用e返回其值
// 请补全代码
    LinkList p = L, s;//下一个的下一个
    int j = 0;
    while (p->next && j < i-1)
    {
        p = p->next;
        j++;
    }

    if (!p->next || j > i+1)
        return false;

    s = p->next;
    e = s->data;

    p->next = p->next->next;
    
    delete s;
    return OK;
}

int main()
{
 LinkList T;
 int a,n,i;
 ElemType x, e;
 printf("Please input the init size of the linklist:\n");
 scanf("%d",&n);
 printf("Please input the %d element of the linklist:\n", n);
 if(CreateLink_L(T, n))     // 判断链表是否创建成功，请填空
 {
	 printf("A Link List Has Created.\n");
	 LoadLink_L(T);
 }
 while(1)
	{
		printf("1:Insert element\n2:Delete element\n3:Load all elements\n0:Exit\nPlease choose:\n");
		scanf("%d",&a);
		switch(a)
		{
			case 1: scanf("%d%d",&i,&x);
				  if(!LinkInsert_L(T, i, x)) printf("Insert Error!\n"); // 判断i值是否合法，请填空
				  else printf("The Element %d is Successfully Inserted!\n", x);
				  break;
			case 2: scanf("%d",&i);
				  if(!LinkDelete_L(T,i,e)) printf("Delete Error!\n"); // 判断i值是否合法，请填空
				  else printf("The Element %d is Successfully Deleted!\n", e);
				  break;
			case 3: LoadLink_L(T);
				  break;
			case 0: return 1;
		}
	}
}
```

易错点：

1. 不要遗漏数据，p->data = e；

2. 注意插入、删除的条件，两者遍历的条件都是j < i - 1，但是删除时判断的是p->next；

3. 注意函数调用时传递的参数；

   

##### **8580	合并链表** 

```C++
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

int main(void)
{
    vector<int> a, b, c;
    int n, e;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &e);
        a.push_back(e);
        c.push_back(e);
    }
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &e);
        b.push_back(e);
        c.push_back(e);
    }
    sort(c.begin(), c.end());

    printf("List A:");
        for (int i = 0; i < a.size(); i++)
            printf("%d ", a[i]);
        printf("\n");

    printf("List B:");
        for (int i = 0; i < b.size(); i++)
            printf("%d ", b[i]);
        printf("\n");

    printf("List C:");
        for (int i = 0; i < c.size(); i++)
            printf("%d ", c[i]);
        printf("\n");
    return 0;
}

```

备注：同合并顺序表一样，使用STL库偷懒，并没有按照题目要求写；



##### **19080	反转链表 **

```C++
        nex = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nex;
```



##### **8583	顺序栈的基本操作 **

```c++
#include<malloc.h>
#include<stdio.h>
#define OK 1
#define ERROR 0
#define STACK_INIT_SIZE 100 // 存储空间初始分配量
#define STACKINCREMENT 10 // 存储空间分配增量

typedef int SElemType; // 定义栈元素类型
typedef int Status; // Status是函数的类型,其值是函数结果状态代码，如OK等

struct SqStack
{
     SElemType *base; // 在栈构造之前和销毁之后，base的值为NULL
     SElemType *top; // 栈顶指针
     int stacksize; // 当前已分配的存储空间，以元素为单位
}; // 顺序栈

Status InitStack(SqStack &S)
{
// 构造一个空栈S，该栈预定义大小为STACK_INIT_SIZE
// 请补全代码
    S.base = new SElemType[STACK_INIT_SIZE];
        if (!S.base)
            return false;

    S.stacksize = STACK_INIT_SIZE;
    S.top = S.base;
    return true;
}

Status Push(SqStack &S,SElemType e)
{
// 在栈S中插入元素e为新的栈顶元素
// 请补全代码
	if (S.top - S.base == S.stacksize)
        return false;
    *S.top++ = e;
    return true;
}

Status Pop(SqStack &S,SElemType &e)
{
// 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
// 请补全代码
	if (S.top == S.base)
        return false;
    e = *--S.top;
    return true;
}

Status GetTop(SqStack S,SElemType &e)
{
// 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR
// 请补全代码
	if (S.top == S.base)
        return false;
    e = *(S.top - 1);
    return true;
}

int StackLength(SqStack S)
{
// 返回栈S的元素个数
// 请补全代码
	return S.top - S.base;
}

Status StackTraverse(SqStack S)
{
// 从栈顶到栈底依次输出栈中的每个元素
	SElemType * p  =  S.top;        //请填空
	if(S.top == S.base) printf("The Stack is Empty!"); //请填空
	else
	{
		printf("The Stack is: ");
		while(p != S.base)            //请填空
		{
            p--;               //请填空
			printf("%d ", *p);

		}
	}
	printf("\n");
	return OK;
}

int main()
{
     int a;
     SqStack S;
SElemType x, e;
     if(InitStack(S))    // 判断顺序表是否创建成功，请填空
{
	printf("A Stack Has Created.\n");
}
while(1)
	{
    printf("1:Push \n2:Pop \n3:Get the Top \n4:Return the Length of the Stack\n5:Load the Stack\n0:Exit\nPlease choose:\n");
	scanf("%d",&a);
		switch(a)
		{
			case 1: scanf("%d", &x);
		      if(!Push(S, x)) printf("Push Error!\n"); // 判断Push是否合法，请填空
		      else printf("The Element %d is Successfully Pushed!\n", x);
		      break;
		case 2: if(!Pop(S, e)) printf("Pop Error!\n"); // 判断Pop是否合法，请填空
			  else printf("The Element %d is Successfully Poped!\n", e);
		  	  break;
		case 3: if(!GetTop(S, e))printf("Get Top Error!\n"); // 判断Get Top是否合法，请填空
			  else printf("The Top Element is %d!\n", e);
		   	  break;
			case 4: printf("The Length of the Stack is %d!\n",StackLength(S)); //请填空
				  break;
			case 5: StackTraverse(S);  //请填空
				  break;
			case 0: return 1;
		}
	}
}
```



##### **8584	循环队列的基本操作 **

```C++
#include<malloc.h>
#include<stdio.h>
#define OK 1
#define ERROR 0
typedef int Status; // Status是函数的类型,其值是函数结果状态代码，如OK等
typedef int QElemType;
#define MAXQSIZE 100 // 最大队列长度(对于循环队列，最大队列长度要减1)

typedef struct
{
   QElemType *base; // 初始化的动态分配存储空间
   int front; // 头指针,若队列不空,指向队列头元素
   int rear; // 尾指针,若队列不空,指向队列尾元素的下一个位置
 }SqQueue;

Status InitQueue(SqQueue &Q)
{
// 构造一个空队列Q，该队列预定义大小为MAXQSIZE
// 请补全代码
    Q.base = new QElemType[MAXQSIZE];
    if (!Q.base)
        return false;
    Q.front = Q.rear = 0;
    return true;

}

Status EnQueue(SqQueue &Q,QElemType e)
{
// 插入元素e为Q的新的队尾元素
// 请补全代码
    if ((Q.rear + 1) % MAXQSIZE == Q.front)
        return false;
    Q.base[Q.rear] = e;
    Q.rear = (Q.rear + 1) % MAXQSIZE;
    return true;
}

Status DeQueue(SqQueue &Q, QElemType &e)
{
// 若队列不空, 则删除Q的队头元素, 用e返回其值, 并返回OK; 否则返回ERROR
// 请补全代码
	if (Q.rear == Q.front)
        return false;
    e = Q.base[Q.front];
    Q.front = (Q.front + 1) % MAXQSIZE;
    return true;
}

Status GetHead(SqQueue Q, QElemType &e)
{
// 若队列不空，则用e返回队头元素，并返回OK，否则返回ERROR
// 请补全代码
	if (Q.front == Q.rear)
        return false;
    e = Q.base[Q.front];
    return true;
}

int QueueLength(SqQueue Q)
{
// 返回Q的元素个数
// 请补全代码
	return (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}

Status QueueTraverse(SqQueue Q)
{
// 若队列不空，则从队头到队尾依次输出各个队列元素，并返回OK；否则返回ERROR.
	int i;
	i=Q.front;
	if(Q.front == Q.rear)printf("The Queue is Empty!");  //请填空
	else{
		printf("The Queue is: ");
		while(i != Q.rear)     //请填空
		{
			printf("%d ",Q.base[i] );   //请填空
			i = (i + 1) % MAXQSIZE;   //请填空
		}
	}
	printf("\n");
	return OK;
}

int main()
{
	int a;
  SqQueue S;
	QElemType x, e;
  if(InitQueue(S))    // 判断顺序表是否创建成功，请填空
	{
		printf("A Queue Has Created.\n");
	}
	while(1)
	{
	printf("1:Enter \n2:Delete \n3:Get the Front \n4:Return the Length of the Queue\n5:Load the Queue\n0:Exit\nPlease choose:\n");
		scanf("%d",&a);
		switch(a)
		{
			case 1: scanf("%d", &x);
				  if(!EnQueue(S, x)) printf("Enter Error!\n"); // 判断入队是否合法，请填空
				  else printf("The Element %d is Successfully Entered!\n", x);
				  break;
			case 2: if(!DeQueue(S, e)) printf("Delete Error!\n"); // 判断出队是否合法，请填空
				  else printf("The Element %d is Successfully Deleted!\n", e);
				  break;
			case 3: if(!GetHead(S, e))printf("Get Head Error!\n"); // 判断Get Head是否合法，请填空
				  else printf("The Head of the Queue is %d!\n", e);
				  break;
			case 4: printf("The Length of the Queue is %d!\n",QueueLength(S));  //请填空
				  break;
			case 5: QueueTraverse(S); //请填空
				  break;
			case 0: return 1;
		}
	}
}

```

易错点：

1. 一定要注意函数的要求，是返回值还是返回状态；

   

##### **8585	栈的应用——进制转换 **

```C++
#include <cstdio>
#include <stack>

using namespace std;

int main(void)
{
    stack<int> output;
    int n;
    scanf("%d", &n);
    while (n || !output.empty())
    {
        if (n)
        {
            output.push(n % 8);
            n /= 8;
        }
        else
        {
            printf("%d", output.top());
            output.pop();
        }
    }
    return 0;
}

```

```C++
#include <cstdio>

int main(void)
{
    int n;
    scanf("%d", &n);
    printf("%o", n);
    return 0;
}

```



##### **8586	括号匹配检验 **

```C++
typedef char SElemType;
#include"malloc.h"
#include"stdio.h"
#include"math.h"
#include"stdlib.h" // exit()
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
typedef int Status; // Status是函数的类型,其值是函数结果状态代码，如OK等
#define STACK_INIT_SIZE 10 // 存储空间初始分配量
#define STACKINCREMENT 2 // 存储空间分配增量
struct SqStack
{
    SElemType *base; // 在栈构造之前和销毁之后，base的值为NULL
    SElemType *top; // 栈顶指针
    int stacksize; // 当前已分配的存储空间，以元素为单位
}; // 顺序栈
Status InitStack(SqStack &S)
{
    S.base = new SElemType[STACK_INIT_SIZE];
    if (!S.base)
        return false;
    S.stacksize = STACK_INIT_SIZE;
    S.top = S.base;
    return true;
}

Status StackEmpty(SqStack S)
{
    if (S.top == S.base)
        return true;
    else
        return false;
}
Status Push(SqStack &S,SElemType e)
{
    if (S.top - S.base == S.stacksize)
        return false;
    else
        *S.top++ = e;
    return true;
}
Status Pop(SqStack &S,SElemType &e)
{
    if (S.top == S.base)
        return false;
    e = *--S.top;
    return true;
}
void check()
{
    // 对于输入的任意一个字符串，检验括号是否配对
    SqStack s;
    SElemType ch[80],*p,e;
    if(InitStack(s)) // 初始化栈成功
    {
        //printf("请输入表达式\n");
        gets(ch);
        p=ch;
        while(*p) // 没到串尾
            switch(*p)
            {
            case '(':
            case '[':
                Push(s, *p++);
                break; // 左括号入栈，且p++
            case ')':
            case ']':
                if(!StackEmpty(s)) // 栈不空
                {
                    Pop(s, e); // 弹出栈顶元素
                    if(*p==')'&&e!='('||*p==']'&&e!='[')
                        // 弹出的栈顶元素与*p不配对
                    {
                        printf("isn't matched pairs\n");
                        exit(ERROR);
                    }
                    else
                    {
                        p++;
                        break; // 跳出switch语句
                    }
                }
                else // 栈空
                {
                    printf("lack of left parenthesis\n");
                    exit(ERROR);
                }
            default:
                p++; // 其它字符不处理，指针向后移
            }
        if(StackEmpty(s)) // 字符串结束时栈空
            printf("matching\n");
        else
            printf("lack of right parenthesis\n");
    }
}
int main()
{
    check();
}

```



##### **8587	行编辑程序 **

```C++
typedef char SElemType;
#include"malloc.h"
#include"stdio.h"
#include"math.h"
#include"stdlib.h" // exit()
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
typedef int Status; // Status是函数的类型,其值是函数结果状态代码，如OK等
#define STACK_INIT_SIZE 100 // 存储空间初始分配量
#define STACKINCREMENT 2 // 存储空间分配增量
struct SqStack
{
    SElemType *base; // 在栈构造之前和销毁之后，base的值为NULL
    SElemType *top; // 栈顶指针
    int stacksize; // 当前已分配的存储空间，以元素为单位
}; // 顺序栈

Status InitStack(SqStack &S)
{
    // 构造一个空栈S
    S.base = new SElemType[STACK_INIT_SIZE];
    if (!S.base)
        return false;
    S.stacksize = STACK_INIT_SIZE;
    S.top = S.base;
}
Status StackEmpty(SqStack S)
{
    // 若栈S为空栈，则返回TRUE，否则返回FALSE
    if (S.top == S.base)
        return true;
    else
        return false;
}
Status ClearStack(SqStack &S)
{
    // 把S置为空栈
    S.top=S.base;
    return OK;
}
Status DestroyStack(SqStack &S)
{
    // 销毁栈S，S不再存在
    free(S.base);
    S.base=NULL;
    S.top=NULL;
    S.stacksize=0;
    return OK;
}
Status Push(SqStack &S,SElemType e)
{
    // 插入元素e为新的栈顶元素
    if (S.top - S.base == S.stacksize)
        return false;
    *S.top++ = e;
    return true;
}
Status Pop(SqStack &S,SElemType &e)
{
    // 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
    if (S.top == S.base)
        return false;
    e = *--S.top;
    return true;
}
Status StackTraverse(SqStack S,Status(*visit)(SElemType))
{
    // 从栈底到栈顶依次对栈中每个元素调用函数visit()。
    // 一旦visit()失败，则操作失败
    while(S.top>S.base)
        visit(*S.base++);
    printf("\n");
    return OK;
}
Status visit(SElemType c)
{
    printf("%c",c);
    return OK;
}
void LineEdit()
{
    // 利用字符栈s，从终端接收一行并送至调用过程的数据区。算法3.2
    SqStack s;
    char ch,c;
    int n,i;
    InitStack(s);
    scanf("%d",&n);
    ch=getchar();
    for(i=1; i<=n; i++)
    {
        ch=getchar();
        while(ch!='\n')
        {
            switch(ch)
            {
            case '#':
                Pop(s,c);
                break; // 仅当栈非空时退栈
            case '@':
                ClearStack(s);
                break; // 重置s为空栈
            default :
                Push(s, ch); // 有效字符进栈
            }
            ch = getchar(); // 从终端接收下一个字符
        }
        StackTraverse(s, visit); // 将从栈底到栈顶的栈内字符输出
        ClearStack(s); // 重置s为空栈
    }
    DestroyStack(s);
}
int main(void)
{
    LineEdit();
    return 0;
}

```



##### **18938	汉诺塔问题** 

```C++
#include <cstdio>

int hanoi(int n, int a, int b, int c)
{
    if (n == 0)
        return 0;

    hanoi(n - 1, a, c, b);
    printf("%c->%d->%c\n", a, n, b);
    hanoi(n - 1, c, b, a);
}

int main(void)
{
    int n;
    int a, b, c;
    scanf("%d %c %c %c", &n, &a, &b, &c);
    hanoi(n, a, b, c);
    return 0;
}

```



##### **18937 阿克曼(Ackmann)函数**

```C++
#include <cstdio>

int akm(int m, int n)
{
    if (m == 0)
        return n + 1;
    else if (m > 0 && n == 0)
        return akm(m - 1, 1);
    else if (m > 0 && n > 0)
        return akm(m - 1, akm(m, n - 1));
}

int main(void)
{
    int m, n;
    scanf("%d %d", &m, &n);
    printf("%d", akm(m, n));
    return 0;
}

```



##### **8592	KMP算法 **

```c++
#include "stdio.h"
#include "stdlib.h"
#include <iostream>
#define TRUE  1
#define FALSE  0
#define OK  1
#define ERROR  0
#define INFEASLBLE  -1
#define OVERFLOW  -2
#define MAXSTRLEN  255 	//用户可在255以内定义最大串长
typedef unsigned char SString[MAXSTRLEN+1];	//0号单元存放串的长度
int next[MAXSTRLEN];
void get_next(SString T)
{
// 算法4.7
// 求模式串T的next函数值并存入数组next
    // 请补全代码
    int i = 1, j = 0;
    next[1] = 0;

    while (i < T[0])
    {
        if (j == 0 || T[i] == T[j])
        {
            i++;
            j++;
            next[i] = j;
        }
        else
            j = next[j];
    }

}

int Index_KMP(SString S,SString T,int pos)
{
// 算法4.6
// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置
// KMP算法。请补全代码
    int i = 1, j = 1;
    while (i <= S[0] && j <= T[0])
    {
        if (j == 0 || S[i] == T[j])
        {
            ++i;
            ++j;
        }
        else
            j = next[j];
    }

    if (j > T[0])
        return i - T[0];
    else
        return false;
}
int main(void)
{
    SString T,S;
    int i,j,n;

    char ch;
    int pos;
    scanf("%d",&n);    // 指定n对需进行模式匹配的字符串
    ch=getchar();
    for(j=1; j<=n; j++)
    {
        ch=getchar();
        for( i=1; i<=MAXSTRLEN&&(ch!='\n'); i++)  // 录入主串
        {
            S[i]=ch;
            ch=getchar();
        }
        S[0]=i-1;    // S[0]用于存储主串中字符个数
        ch=getchar();
        for( i=1; i<=MAXSTRLEN&&(ch!='\n'); i++)  // 录入模式串
        {
            T[i]=ch;
            ch=getchar();
        }
        T[0]=i-1;    // T[0]用于存储模式串中字符个数
        pos= Index_KMP(S, T, 0)     ;    // 请填空
        printf("%d\n",pos);
    }
}

```

备注：考试的时候会计算NEXT值即可；



##### **18769	不完整的排序 **

```C++
#include <cstdio>
#include <vector>

using namespace std;

int main(void)
{
    vector<int> arr;
    int t;
    int n;
    scanf("%d", &t);

    while(t--)
    {
        scanf("%d", &n);
        for (int i = 0; i < n; i++)
        {
            int e;
            scanf("%d", &e);
            arr.push_back(e);
        }

        int * left, * right;
        left = &arr[0], right = &arr[arr.size()-1];

        while (left < right)
        {
            while(*left < 0)
                left++;
            while(*right > 0)
                right--;

            if (left < right)
            {
                int temp;
                temp = *left;
                *left = *right;
                *right = temp;
            }
        }

        for (int i = 0; i < n; i++)
            printf("%d ", arr[i]);
        printf("\n");

        arr.clear();
    }
}
```

备注：使用STL库中的<vector>函数；

易错点：

1. 只有当（left < right) 的情况需要交换数值；

2. 处理完第一个字符串后，需要执行arr. clear()函数，清空vector；

   

##### **8606	二叉树的构建及遍历操作 **

```C++
#include "stdio.h"
#include "malloc.h"
#define TRUE 1
#define FALSE 0
#define OK  1
#define ERROR  0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int  Status;

typedef char  ElemType;
typedef struct BiTNode
{
    ElemType data;
    struct BiTNode *lchild,*rchild;//左右孩子指针
} BiTNode,*BiTree;

Status CreateBiTree(BiTree &T)    // 算法6.4
{
    // 按先序次序输入二叉树中结点的值（一个字符），’#’字符表示空树，
    // 构造二叉链表表示的二叉树T。
    char ch;
    scanf("%c",&ch);
    if (ch=='#') T = NULL;
    else
    {
        if (!(T = (BiTNode *)malloc(sizeof(BiTNode)))) return ERROR;
        T = new BiTNode; // 生成根结点
        T->data = ch;
        CreateBiTree(T->lchild);  // 构造左子树
        CreateBiTree(T->rchild); // 构造右子树
    }
    return OK;
} // CreateBiTree

Status PreOrderTraverse( BiTree T)
{
    // 前序遍历二叉树T的递归算法
    if (!T)
        return 0;
    printf("%c", T->data);
    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
} // PreOrderTraverse

Status InOrderTraverse( BiTree T)
{
    // 中序遍历二叉树T的递归算法
    //补全代码,可用多个语句
    if (!T)
        return 0;
    InOrderTraverse(T->lchild);
    printf("%c", T->data);
    InOrderTraverse(T->rchild);
} // InOrderTraverse

Status PostOrderTraverse( BiTree T)
{
    if (!T)
        return 0;
    PostOrderTraverse(T->lchild);
    PostOrderTraverse(T->rchild);
    printf("%c", T->data);
} // PostOrderTraverse

int main()   //主函数
{
    BiTree T;
    CreateBiTree(T);
    PreOrderTraverse(T);
    printf("\n");
    InOrderTraverse(T);
    printf("\n");
    PostOrderTraverse(T);
    return 0;
}//main

```

易错点:

1. 漏掉"T->data = ch"语句，结点没有储存对应的值;

2. 任何遍历都要有出口，"if (T == NULL) return 0;" 防止出现栈溢出的情况；

   

##### **17121	求二叉树各种节点数 **

```C++
#include "stdio.h"
#include "malloc.h"
#define TRUE 1
#define FALSE 0
#define OK  1
#define ERROR  0
#define INFEASIBLE -1
#define OVERFLOW -2
typedef int  Status;

typedef char  ElemType;
typedef struct BiTNode
{
    ElemType data;
    struct BiTNode *lchild,*rchild;//左右孩子指针
} BiTNode,*BiTree;

Status CreateBiTree(BiTree &T)    // 算法6.4
{
    // 按先序次序输入二叉树中结点的值（一个字符），’#’字符表示空树，
    // 构造二叉链表表示的二叉树T。
    char ch;
    scanf("%c",&ch);
    if (ch=='#') T = NULL;
    else
    {
        if (!(T = (BiTNode *)malloc(sizeof(BiTNode)))) return ERROR;
        T = new BiTNode;
        T->data = ch;
        // 生成根结点
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
} // CreateBiTree

int d0 = 0, d1 = 0, d2 = 0;

int PreOrderTraverse(BiTree T)
{
    if (T == NULL)
        return 0;
    if (T->lchild && T->rchild)
        d2++;
    else  if(!T->lchild && !T->rchild)
        d0++;
    else if (T->lchild && !T->rchild || !T->lchild && T->rchild)
        d1++;

    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
}

int main()   //主函数
{
    //补充代码
    BiTree T;
    CreateBiTree(T);
    PreOrderTraverse(T);
    printf("%d\n%d\n%d", d2, d1, d0);
    return 0;
}//main

```

备注：用先序遍历+if的手段检查每一个结点；



##### **18924	二叉树的宽度 **

```C++
#include <cstdio>
#include <queue>

using namespace std;

int tree[105][2];

int main(void)
{
    queue<int> cur;
    int n, width = 1;
    scanf("%d", &n);

    for (int i = 1; i < n; i++)
    {
        int x, y;
        scanf("%d %d", &x, &y);
        if(!tree[x][0])
            tree[x][0] = y;
        else
            tree[x][1] = y;
    }

    int pos;

    cur.push(1);
    while(!cur.empty())
    {
        int len = cur.size(); //记录队列的大小
        width = (width > len) ? width : len; //记录最宽值
        //printf("%d\n", width);

        for (int i = 0; i < len; i++)//将队列中所有的结点弹出，压入队列中所有结点的字数
        {
            pos = cur.front();
            cur.pop();

            if (tree[pos][0])
                cur.push(tree[pos][0]);
            if (tree[pos][1])
                cur.push(tree[pos][1]);
        }
    }
    printf("%d", width);
    return 0;
}

```

易错点：

1. 循环的条件式"!cur. empty()"，而且在循环开始前要先cur. push(1)，将1压入队列;
2. 要记录当前队列的长度，len = cur.size()；
3. 要记录最大值width；



##### **18724	二叉树的遍历运算 **

```C++
#include <iostream>
#include <cstdio>
#include <string>

using namespace std;

string pre, in;
void solve(int pre_root, int start, int end)//先序遍历的根节点， 中序遍历的范围
{
    if (start > end)//不存在子节点
        return ;

    int i = start;
    for (i = start; i < end && in[i] != pre[pre_root]; i++); //在中序遍历中，找到根节点。该节点可以分出左右子树。
    
    solve(pre_root + 1, start, i - 1); 				 //pre_root + 1根节点的左子树, i - 1为左子树的最后一个节点
    solve(i + 1, i + 1, end);//左子树的节点总数 + 1 ＝ 右子树，i + 1为右子树的第一个节点
  //solve(i + 1, i + 1, end); 可以直接写成
    cout << in[i];
}

int main(void)
{
    cin >> pre >> in;

    solve(0, 0, pre.length()-1);
    return 0;
}

```

备注：难以理解的话，背下来即可。



##### **18923	二叉树的直径  **

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int tree[55][2];
int depth = 0;

int dfs(int root)
{
    if (!root)
        return 0;
    int lchild = dfs(tree[root][0]);//左子树DFS
    int rchild = dfs(tree[root][1]);//右子树DFS

    int len = max(lchild, rchild) + 1;//选择当前结点最深的子树
    depth = max(depth, lchild + rchild);
    return len;
}

int main(void)
{
    int n;
    scanf("%d", &n);

    for (int i = 1; i < n; i++)
    {
        int x, y;
        scanf("%d %d", &x, &y);

        if (!tree[x][0])
            tree[x][0] = y;
        else
            tree[x][1] = y;
    }

    dfs(1);
    printf("%d", depth);
    return 0;
}
```

备注：这道题不难，只要掌握DFS算法即可；

易错点：

1. 要注意 len还需要加上当前结点的值，len = max(lchild, rchild) + 1；

2. 看清楚题目要求，直径是一个结点到另一个结点，所以是lchild + rchild；

   

##### **8610	顺序查找 **

```c++
#include <cstdio>

int main(void)
{
    int * num;
    int n;
    scanf("%d", &n);

    num = new int[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &num[i]);

    int key, index = 0;
    scanf("%d", &key);
    for (index = 0; num[index] != key && index < n; index++);

    if (num[index] == key)
        printf("The element position is %d.", index + 1);
    else
        printf("The element is not exist.");
    return 0;
}
```

备注：简简单单平平无奇顺序查找；

​	易错点：注意查找的条件，1. num[index] != key； 2.  index < n；

##### **8621	二分查找 **

```C++
//偷懒法 （沿用了上一题的代码

#include <cstdio>

int main(void)
{
    int * num;
    int n;
    scanf("%d", &n);

    num = new int[n];
    for (int i = 0; i < n; i++)
        scanf("%d", &num[i]);

    int key, index = 0;
    scanf("%d", &key);
    for (index = 0; num[index] != key && index < n; index++);

    if (num[index] == key)
        printf("The element position is %d.", index);
    else
        printf("The element is not exist.");
    return 0;
}

```

```c++
//正常做法
#include <iostream>
#include <cstdio>

using namespace std;

int half_select(int * num, int key);
void swap(int &i, int &j);

int main(void)
{
    int n;
    int key;
    scanf("%d", &n);
    int * num = new int[n+1];
    num[0] = n;
    for (int i = 1; i <= n; i++)
        scanf("%d", &num[i]);

    scanf("%d", &key);
    half_select(num, key);

    return 0;
}

int half_select(int * num, int key)
{
    int left, right, mid;

    left = 1, right = num[0];
    mid = (left + right) / 2;
    while (left <= right)
    {
        if (key > num[mid])
        {
            left = mid + 1;
            mid = (left + right) / 2;
        }
        else if (key < num[mid])
        {
            right = mid - 1;
            mid = (left + right) / 2;
        }
        else if (key == num[mid])
        {
            printf("The element position is %d.", mid-1);
            return 0;
        }
    }

    printf("The element is not exist.");
    return 0;
}


void swap(int &i, int &j)
{
    int temp = i;
    i = j;
    j = temp;
}

```



##### **8622	哈希查找 **

```c++
#include"malloc.h" /* malloc()等 */
#include"stdlib.h" /* exit() */
#include"stdio.h"
#define EQ(a,b) ((a)==(b))
#define SUCCESS 1
#define UNSUCCESS 0
#define NULLKEY -1 /*哈希表无元素时值为-1*/
typedef int ElemType;
int length;
typedef struct
{
    ElemType *elem; /* 数据元素存储基址，动态分配数组 */
    int count; /* 当前数据元素个数 */
} HashTable;

void InitHashTable(HashTable *H)
{
    /* 操作结果: 构造一个长度为length的哈希表,length为全局变量 */
    int i;
    (*H).count=0; /* 当前元素个数为0 */
    (*H).elem=(ElemType*)malloc(length*sizeof(ElemType));
    if(!(*H).elem)
        exit(0); /* 存储分配失败 */
    for(i=0; i<length; i++)
        (*H).elem[i]=NULLKEY; /* 未填记录的标志 */
}
unsigned Hash(ElemType K)
{
    /* 一个简单的哈希函数*/
    int result;
    result = (3 * K) % length;
    return result;
}
void collision(int *p) /*线性探测再散列 */
{
    /* 开放定址法处理冲突 */
    *p = (*p + 1) % length;
}
int SearchHash(HashTable H,ElemType K,int *p,int *c)
{
    /* 在开放定址哈希表H中查找关键码为K的元素,若查找成功,以p指示待查数据 */
    /* 元素在表中位置,并返回SUCCESS;否则,以p指示插入位置,并返回UNSUCCESS */
    /* c用以计冲突次数，其初值置零，供建表插入时参考。算法9.17 */
    *p=Hash(K); /* 求得哈希地址 */
    while(H.elem[*p]!=NULLKEY&&!EQ(K,H.elem[*p]))
    {
        /* 该位置中填有记录,并且关键字不相等 */
        (*c)++;
        if(*c<length)
            collision(p); /* 求得下一探查地址p */
        else
            break;
    }
    if EQ(K,H.elem[*p])
        return SUCCESS; /* 查找成功，p返回待查数据元素位置 */
    else
        return UNSUCCESS; /* 查找不成功(H.elem[p].key==NULLKEY)，p返回的是插入位置 */
}
int InsertHash(HashTable *H,ElemType e)
{
    /* 查找不成功时插入数据元素e到开放定址哈希表H中，并返回查找长度 */
    int c,p;
    c=0;
    if(SearchHash(*H,e,&p,&c))   /* 表中已有与e有相同关键字的元素 */
        printf("哈希表中已有元素%d。\n",e);
    else  /* 插入e */
    {
        (*H).elem[p]=e;
        ++(*H).count;
    }
    return c+1; /*查找长度为冲突次数加1*/
}
void TraverseHash(HashTable H)
{
    /* 按哈希地址的顺序打印哈希表，无元素位置用X表示 */
    int i;
    //printf("HashTable Address:0～%d\n",length-1);
    for(i=0; i<length; i++)
        if(H.elem[i]==NULLKEY) /* 有数据 */
            printf("X ");
        else
            printf("%d ",H.elem[i]);
    printf("\n");
}
int main(void)
{
    float i=0,j=0;
    ElemType e;
    HashTable H;
    //printf("Input Table length:");
    scanf("%d",&length);
    InitHashTable(&H);
    //printf("Input key words sequence, -1 conclusion input：");
    scanf("%d",&e);
    while(e!=-1)
    {
        j ++;  /*j记录输入元素个数*/
        i = i + InsertHash(&H,e);  /*i记录查找长度的和*/
        scanf("%d",&e);
    }
    TraverseHash(H);
    printf("Average search length=%f\n",i/j);
}

```



##### **8638	直接插入排序 **

```C++
#include <cstdio>

int main(void)
{
    int * arr;
    int n;
    scanf("%d", &n);

    arr = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    for (int i = 1; i < n; i++)
    {
        int key = arr[i];
        int j;
        for (j = i - 1; j >= 0 && arr[j] > key; j--)
            arr[j + 1] = arr[j];
        arr[j + 1] = key;
        for (int k = 0; k < n; k++)
            printf("%d ", arr[k]);
        printf("\n");
    }
    return 0;
}

```

实现思路：从第二个元素开始，将当前元素与已排序的元素逐个比较并插入到正确的位置。



##### **8639	折半插入排序 **

```C++
#include <cstdio>

int main(void)
{
    int * arr;
    int n;
    scanf("%d", &n);

    arr = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    for (int i = 1; i < n; i++)
    {
        int key = arr[i];
        int low = 0, high = i - 1;

        while (low <= high)
        {
            int m = (low + high) / 2;
            if (key < arr[m])
                high = m - 1;
            else
                low = m + 1;
            //printf("Low is %d, High is %d\n", low, high);
        }
		
        int j;
        for (j = i - 1; j >= low; j--)
            arr[j + 1] = arr[j];
        arr[j + 1] = key;

        for (int k = 0; k < n; k++)
            printf("%d ", arr[k]);
        printf("\n");
    }

    return 0;
}

```

实现思路：使用二分查找找到当前元素在已排序序列中的插入位置，然后将其插入到该位置。

备注：考试的时候不清楚插入位置，可以printf("%d %d", arr[low], arr[high]); 查看一下嘛！



##### **8640	希尔(shell)排序 **

```c++
#include <cstdio>

int dt[100];
int ts = 0;

void ShellInsert(int * arr, int dk, int n)
{
    for (int i = dk; i < n; i++)
    {
        int key = arr[i];
        int j = i - dk;

        for (j = i - dk; j >= 0 && arr[j] > key; j-=dk)
            arr[j + dk] = arr[j];
        arr[j + dk] = key;
    }
    for (int k = 0; k < n; k++)
        printf("%d ", arr[k]);
    printf("\n");
}

void ShellSort(int * arr, int dt[], int t, int n)
{
    for (int k = 0; k < t; k++)
        ShellInsert(arr, dt[k], n);
}

int main(void)
{
    int * arr;
    int n;
    scanf("%d", &n);

    dt[0] = n/2;
    int cur = n/2;
    while(cur)
    {
        dt[ts++] = cur / 2;
        cur /= 2;
    }

    arr = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    ShellSort(arr, dt, ts, n);

    return 0;
}

```

实现思路：将数组按照一定的间隔分组，对每个分组进行插入排序，然后逐渐缩小间隔直到为1。



##### **8641	冒泡排序 **

```C++
#include <cstdio>
#include <algorithm>
using namespace std;
int main(void)
{
    int * arr;
    int n, flag = 0;
    scanf("%d", &n);

    arr = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    for (int i = 0; i < n - 1; i++)
    {
        flag = 0;
        for (int j = 0; j < n - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                swap(arr[j], arr[j+1]);
                flag++;
            }

        }
        if (flag)
        {
             for (int k = 0; k < n; k++)
                printf("%d ", arr[k]);
            printf("\n");
        }

    }
    for (int k = 0; k < n; k++)
       printf("%d ", arr[k]);
    printf("\n");
    return 0;
}

```

实现思路：从数组的第一个元素开始，比较相邻的两个元素，如果顺序错误则交换，直到整个数组排序完成。



##### **8642	快速排序 **

```C++
#include <cstdio>
#include <algorithm>
using namespace std;

int Partition(int * arr, int low, int high, int n)
{
    int pivotkey = arr[low];
    while (low < high)
    {
        while (low < high && arr[high] >= pivotkey)
            --high;
        arr[low] = arr[high];
        while (low < high && arr[low] <= pivotkey)
            ++low;
        arr[high] = arr[low];
    }
    arr[low] = pivotkey;
    
        for (int k = 0; k < n; k++)
            printf("%d ", arr[k]);
        printf("\n");

    return low;
}

void QSort(int * arr, int low, int high, int n)
{
    if (low < high)
    {
        int Pivot = Partition(arr, low, high, n);
        QSort(arr, low, Pivot - 1, n);
        QSort(arr, Pivot + 1, high, n);
    }
}

int main(void)
{
    int * arr;
    int n;
    scanf("%d", &n);

    arr = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    QSort(arr, 0, n - 1, n);
    return 0;
}
```

实现思路：选择一个基准元素，将小于基准的元素放在其左边，大于基准的元素放在其右边，然后对左右两个子数组进行递归快速排序。



##### **8643	简单选择排序 **

```C++
#include <cstdio>
#include <algorithm>
using namespace std;


int main(void)
{
    int * arr;
    int n;
    scanf("%d", &n);

    arr = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    int min, index;

    for (int i = 0; i < n - 1; i++)
    {
        min = arr[i];
        for (int j = i; j < n; j++)
        {
            if (arr[j] < min)
            {
                min = arr[j];
                index = j;
            }
        }
        if (min != arr[i])
            swap(arr[i], arr[index]);
        for (int k = 0; k < n; k++)
            printf("%d ", arr[k]);
        printf("\n");
    }
    return 0;
}

```

实现思路：每次从未排序的元素中选择最小的元素，然后与未排序序列的第一个元素交换位置。



##### **8644	堆排序 **

```C++
#include <cstdio>
#include <algorithm>
using namespace std;

void heap_adjust(int * arr, int s, int m)
{
    int key = arr[s];

    for (int j = 2 * s; j <= m; j *= 2)
    {
        if (j < m && arr[j] < arr[j + 1])   j++;

        if (key >= arr[j])
            break;

        arr[s] = arr[j], s = j;
    }
    arr[s] = key;
}

void CreateHeap(int * arr)
{
    int i = arr[0], j = arr[0] / 2;
    for (j; j > 0; j--)
        heap_adjust(arr, j, i);

        for (int k = 1; k <= arr[0]; k++)
            printf("%d ", arr[k]);
        printf("\n");
}

void HeapSort(int * arr)
{

    CreateHeap(arr);

    for (int i = arr[0]; i > 1; i--)
    {
        int x = arr[1];
        arr[1] = arr[i];
        arr[i] = x;
        heap_adjust(arr, 1, i - 1);
        for (int k = 1; k <= arr[0]; k++)
            printf("%d ", arr[k]);
        printf("\n");
    }
}

int main(void)
{
    int * arr;
    int n;
    scanf("%d", &n);

    arr = new int[n + 1];

    for (int i = 1; i <= n; i++)
        scanf("%d", &arr[i]);

    arr[0] = n;
    HeapSort(arr);
    return 0;
}

```

堆排序：将数组构建成一个最大堆，然后将堆顶元素与堆的最后一个元素交换，再对剩余的元素进行堆调整，重复该过程直到整个数组有序。



##### **8645	归并排序（非递归算法） **

```C++
//当你乖乖用非递归算法写时
#include <stdio.h>
#include <stdlib.h>

void merge(int arr[], int l, int m, int r)
{#include <cstdio>
#include <algorithm>

using namespace std;

void traverse(int* arr, int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

void merge(int* R, int* T, int low, int mid, int high, int n) {
    int i = low, j = mid + 1, k = low;
    while (i <= mid && j <= high) {
        if (R[i] <= R[j])
            T[k++] = R[i++];
        else
            T[k++] = R[j++];
    }

    while (i <= mid)
        T[k++] = R[i++];
    while (j <= high)
        T[k++] = R[j++];

    for (i = low; i <= high; i++)
        R[i] = T[i];


}

void mergeSort(int* arr, int n) {
    int* temp = new int[n];

    for (int currSize = 1; currSize < n; currSize *= 2) {
        for (int leftStart = 0; leftStart < n - 1; leftStart += 2 * currSize) {
            int mid = leftStart + currSize - 1;
            int rightEnd = min(leftStart + 2 * currSize - 1, n - 1);
            merge(arr, temp, leftStart, mid, rightEnd, n);
        }
        traverse(arr, n);
    }

    delete[] temp;
}

int main() {
    int n;
    scanf("%d", &n);
    int* arr = new int[n];
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    mergeSort(arr, n);

    delete[] arr;
    return 0;
}

    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    // 创建两个临时数组
    int L[n1], R[n2];

    // 将数据复制到临时数组中
    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    // 归并临时数组到原数组
    i = 0; // 左侧数组的起始索引
    j = 0; // 右侧数组的起始索引
    k = l; // 归并后的数组的起始索引
    while (i < n1 && j < n2)
    {
        if (L[i] <= R[j])
        {
            arr[k] = L[i];
            i++;
        }
        else
        {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // 将未归并的剩余元素复制到原数组中
    while (i < n1)
    {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2)
    {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int n)
{
    int curr_size; // 当前合并的数组大小
    int left_start; // 左侧子数组的起始索引

    // 将合并的数组大小从1开始增加到n-1
    for (curr_size = 1; curr_size <= n-1; curr_size = 2*curr_size)
    {
        // 以当前合并的数组大小为间隔，合并左右子数组
        for (left_start = 0; left_start < n-1; left_start += 2*curr_size)
        {
            // 计算中间和右侧子数组的结束索引
            int mid = left_start + curr_size - 1;
            int right_end = (left_start + 2*curr_size - 1 < n-1) ? left_start + 2*curr_size - 1 : n-1;

            // 归并左右子数组
            merge(arr, left_start, mid, right_end);
        }
        for (int i = 0; i < n - 1; i++)
            printf("%d ", arr[i]);
        printf("%d\n", arr[n - 1]);
    }
}

int main()
{
    int n;
    scanf("%d", &n);
    int * arr = new int[n];

    for (int i = 0; i < n; i++)
        scanf("%d", &arr[i]);
    mergeSort(arr, n);
    return 0;
}
```

```C++
//高神特供版 归并排序
#include<iostream>
#include<algorithm>

using namespace std;

int * a;
int n;

void traverse()
{
    for(int i = 1; i <= n; i++)
        cout << a[i] <<" ";
    cout << endl;
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    
    int i, j, d;
    for(d = 2; d < n; d *= 2)
    {
        for(i = 1; i + d - 1 <= n; i += d)
            sort(a[i], a[i + d]);
        traverse();
    }
    sort(a[1], a[n + 1]);
    traverse();
    return 0;
}

```

```
//递归形式
//请注意 递归形式的代码无法通过oj测试
#include <cstdio>

using namespace std;

void traverse(int * arr)
{
    for (int i = 1; i < arr[0]; i++)
        printf("%d ", arr[i]);
    printf("%d\n", arr[arr[0]]);
}

void Merge(int * R, int * T, int low, int mid, int high)
{
    int i = low, j = mid + 1, k = low;
    while(i <= mid && j <= high)
    {
        if (R[i] <= R[j])
            T[k++] = R[i++];
        else
            T[k++] = R[j++];
    }

    while (i <= mid)
        T[k++] = R[i++];
    while (j <= high)
        T[k++] = R[j++];

    traverse(T);
}

void MSort(int * R, int * T, int low, int high)
{
    int mid;
    int * S = new int[R[0] + 1];
    S[0] = R[0];
    if (low == high)
        T[low] = R[low];
    else
    {
        mid = (low + high) / 2;
        MSort(R, S, low, mid);
        MSort(R, S, mid + 1, high);
        Merge(S, T, low, mid, high);

    }
}


int main(void)
{
    int * arr;
    int n;
    scanf("%d", &n);
    arr = new int[n + 1];
    arr[0] = n;
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &arr[i]);
    }

    MSort(arr, arr, 1, n);
    traverse(arr);
    return 0;
}
```

实现思路：将数组不断分割成更小的子数组，然后将子数组两两合并并排序，直到最终整个数组有序。



##### **8647	实现图的存储结构 **

```C++
#include <cstdio>
int graph[105][105];

int main(void)
{
    int m, n;
    scanf("%d %d", &n, &m);

    for (int i = 0; i < m; i++)
    {
        int x, y;
        scanf("%d %d", &x, &y);
        graph[x][y] = 1;
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
            printf("%d ", graph[i][j]);
        printf("\n");
    }
    return 0;
}

```



##### **8648	图的深度遍历 **

```C++
#include <cstring>
#include <cstdio>
#include <cstdlib>

typedef int InfoType;
#define MAX_NAME 3
typedef char VertexType[MAX_NAME];

#define MAX_VERTEX_NUM 20
typedef enum {DG, DN, AG, AN} GraphKind;

typedef struct ArcNode
{
    int adjvex;
    struct ArcNode *nextarc;
    InfoType *info;
} ArcNode;

typedef struct
{
    VertexType data;
    ArcNode *firstarc;
} VNode, AdjList[MAX_VERTEX_NUM];

typedef struct
{
    AdjList vertices;
    int vexnum, arcnum;
    int kind;
} ALGraph;

int LocateVex(ALGraph G, VertexType u)
{
    int i;
    for (i = 0; i < G.vexnum; ++i)
        if (strcmp(u, G.vertices[i].data) == 0)
            return i;
    return -1;
}

void CreateGraph(ALGraph *G)
{
    int i, j, k;
    int w;
    VertexType va, vb;
    ArcNode *p;

    scanf("%d", &G->kind);
    scanf("%d%d", &G->vexnum, &G->arcnum);

    for (i = 0; i < G->vexnum; ++i)
    {
        scanf("%s", G->vertices[i].data);
        G->vertices[i].firstarc = NULL;
    }

    for (k = 0; k < G->arcnum; ++k)
    {
        if (G->kind == 1 || G->kind == 3)
            scanf("%d%s%s", &w, va, vb);
        else
            scanf("%s%s", va, vb);

        i = LocateVex(*G, va);
        j = LocateVex(*G, vb);
        p = (ArcNode *)malloc(sizeof(ArcNode));
        p->adjvex = j;
        if (G->kind == 1 || G->kind == 3)
        {
            p->info = (int *)malloc(sizeof(int));
            *(p->info) = w;
        }
        else
            p->info = NULL;
        p->nextarc = G->vertices[i].firstarc;
        G->vertices[i].firstarc = p;

        if (G->kind >= 2)
        {
            p = (ArcNode *)malloc(sizeof(ArcNode));
            p->adjvex = i;
            if (G->kind == 3)
            {
                p->info = (int *)malloc(sizeof(int));
                *(p->info) = w;
            }
            else
                p->info = NULL;
            p->nextarc = G->vertices[j].firstarc;
            G->vertices[j].firstarc = p;
        }
    }
}

VertexType *GetVex(ALGraph G, int v)
{
    if (v >= G.vexnum || v < 0)
        exit(0);
    return &G.vertices[v].data;
}

int FirstAdjVex(ALGraph G, VertexType v)
{
    ArcNode *p;
    int v1;
    v1 = LocateVex(G, v);
    p = G.vertices[v1].firstarc;
    if (p)
        return p->adjvex;
    else
        return -1;
}

int NextAdjVex(ALGraph G, VertexType v, VertexType w)
{
    ArcNode *p;
    int v1, w1;
    v1 = LocateVex(G, v);
    w1 = LocateVex(G, w);
    p = G.vertices[v1].firstarc;
    while (p && p->adjvex != w1)
        p = p->nextarc;
    if (!p || !p->nextarc)
        return -1;
    else
        return p->nextarc->adjvex;
}

int visited[MAX_VERTEX_NUM];
void (*VisitFunc)(char *);

void print(char *i)
{
    printf("%s ", i);
}

void DFS(ALGraph G, int v)
{
    visited[v] = 1;
    VisitFunc(G.vertices[v].data);
    ArcNode *p = G.vertices[v].firstarc;
    while (p)
    {
        int w = p->adjvex;
        if (!visited[w])
        {
            DFS(G, w);
        }
        p = p->nextarc;
    }
}

void DFSTraverse(ALGraph G, void (*Visit)(char *))
{
    
    for (int v = 0; v < G.vexnum; v++)
    {
        visited[v] = 0;
    }
    for (int v = 0; v < G.vexnum; v++)
    {
        if (!visited[v])
            DFS(G, v);
    }
    printf("\n");
}



int main()
{
    ALGraph g;
    CreateGraph(&g);
    DFSTraverse(g, print);
    return 0;
}

```



##### **8649 图的广度遍历**

```C++

```

